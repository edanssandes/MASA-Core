<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MASA-Core: AbstractAligner Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MASA-Core
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">AbstractAligner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="AbstractAligner" --><!-- doxytag: inherits="IAligner" --><hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Abstract class that executes the Alignment procedure. </p>
<p>The <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> class is the basic implementation of the interface between the portable code and the non-portable code of MASA (Malleable Architecture for <a class="el" href="classSequence.html">Sequence</a> Aligners). Each MASA extension must create its own Aligner class that extend the <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> class. The Aligner class has 3 group of methods:</p>
<ul>
<li>
Public Methods. They are used between the MASA framework and the MASA the public methods; </li>
<li>
Virtual methods. They must be implemented by the non-portable code; </li>
<li>
Protected methods. Simplifies routines common to all aligners. </li>
<li>
Delegate methods. Are methods with protected C++ visibility that may be used to obtain or send information between the Aligner subclass and the MASA framework. </li>
</ul>
<p>Although all the abstract methods must be implemented, the Aligner must also be compliant with many requirements in order to produce a proper integration. If the Aligner is fully compliant with a given requirement, we say that the Aligner has that capability. See the <a class="el" href="structaligner__capabilities__t.html" title="Struct that informs to the MASA framework which capabilities the MASA extension implements.">aligner_capabilities_t</a> struct to see all the proposed requirements. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00064">64</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AbstractAligner:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAbstractAligner.png" usemap="#AbstractAligner_map" alt=""/>
  <map id="AbstractAligner_map" name="AbstractAligner_map">
<area href="classIAligner.html" title="Interface between the MASA extension and the MASA framework." alt="IAligner" shape="rect" coords="160,0,310,24"/>
<area href="classAbstractAlignerSafe.html" title="A thread-safe AbstractAligner extension." alt="AbstractAlignerSafe" shape="rect" coords="0,112,150,136"/>
<area href="classAbstractBlockAligner.html" title="Abstract class that processes blocks individually considering some schedule mechanism." alt="AbstractBlockAligner" shape="rect" coords="160,112,310,136"/>
<area href="classAbstractDiagonalAligner.html" title="Abstract class that processes diagonal of blocks." alt="AbstractDiagonalAligner" shape="rect" coords="320,112,470,136"/>
</map>
 </div></div>

<p><a href="classAbstractAligner-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#af707917b2e834117c777af6c8f9656e1">AbstractAligner</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> contructor.  <a href="#af707917b2e834117c777af6c8f9656e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#ac18a90717146f8c859cfa9af77ce89bc">~AbstractAligner</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> destructor.  <a href="#ac18a90717146f8c859cfa9af77ce89bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a69671d1a0c95a8c6263d79c489dd5354">setManager</a> (<a class="el" href="classIManager.html">IManager</a> *<a class="el" href="classAbstractAligner.html#ad95eca23ac415a19981aae2b7f53875a">manager</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the <a class="el" href="classIManager.html" title="Interface that manages the MASA extension execution.">IManager</a> to be associated with this aligner.  <a href="#a69671d1a0c95a8c6263d79c489dd5354"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a18b6ce3477f0b4a5bbbe108e42aadae9">getForkWeights</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply the computational power weight defined after the <a class="el" href="classAbstractAligner.html#a15085bdaa0b4f829a34db0b5dd55e202" title="Defines how many processes may be forked for this aligner and the computation weight for each process...">AbstractAligner::setForkCount</a>.  <a href="#a18b6ce3477f0b4a5bbbe108e42aadae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmatch__result__t.html">match_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a255fbe4d8b8727ff0b536df6cbf9a473">matchLastColumn</a> (const <a class="el" href="structcell__t.html">cell_t</a> *buffer, const <a class="el" href="structcell__t.html">cell_t</a> *base, int len, int goalScore)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the matching procedure in CPU.  <a href="#a255fbe4d8b8727ff0b536df6cbf9a473"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a15085bdaa0b4f829a34db0b5dd55e202">setForkCount</a> (const int <a class="el" href="classAbstractAligner.html#acde0822aad9e8fe78a5def1006a8ab2b">forkCount</a>, const int *<a class="el" href="classAbstractAligner.html#a7564052368b750d0637c97b5fedc3aab">forkWeights</a>=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how many processes may be forked for this aligner and the computation weight for each process.  <a href="#a15085bdaa0b4f829a34db0b5dd55e202"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrid.html">Grid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a10740e19e79a256a6e8459b43bf8b30d">createGrid</a> (<a class="el" href="classPartition.html">Partition</a> partition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new grid using the given partition coordinates.  <a href="#a10740e19e79a256a6e8459b43bf8b30d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classGrid.html">Grid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a3448cc3cba9423a8758f4d677eac67e5">getGrid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the grid created by the last call to the <a class="el" href="classAbstractAligner.html#a10740e19e79a256a6e8459b43bf8b30d" title="Creates a new grid using the given partition coordinates.">AbstractAligner::createGrid</a> method.  <a href="#a3448cc3cba9423a8758f4d677eac67e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#ac731ae81af1b2040bc2324e114df426f">initializeBlockPruning</a> (<a class="el" href="classAbstractBlockPruning.html">AbstractBlockPruning</a> *blockPruner)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the pruner object.  <a href="#ac731ae81af1b2040bc2324e114df426f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#afacbcb609bbb6d8ebcaafaec73e262af">getRecurrenceType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a1e389d0cf094847cc91b98dd22a155de">IManager::getRecurrenceType()</a>  <a href="#afacbcb609bbb6d8ebcaafaec73e262af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a1446002ca4fe9bfb0ff89983878b46e3">getSpecialRowInterval</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a982e656c11981976af06d53eddb205f8">IManager::getSpecialRowInterval()</a>  <a href="#a1446002ca4fe9bfb0ff89983878b46e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a24722d7768fec9ff4baac7fe1dd1185a">getSpecialColumnInterval</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a8c60a1269909d9388627063d5b48eaef">IManager::getSpecialColumnInterval()</a>  <a href="#a24722d7768fec9ff4baac7fe1dd1185a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a4af4756383624780721d22c831e6bca9">getFirstColumnInitType</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#ae89c12af219f421da96c1ac22af01ea5" title="Returns the initialization type of the first column.">IManager::getFirstColumnInitType()</a>  <a href="#a4af4756383624780721d22c831e6bca9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a38dedb2033c512acd64f544bd0b26a9d">getSuperPartition</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d" title="Returns the super partition that includes all sub partitions being aligned.">IManager::getSuperPartition()</a>  <a href="#a38dedb2033c512acd64f544bd0b26a9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a2ab4132fcf3c30fd649a44eae598abb9">getFirstRowInitType</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a41254fba0cfeccbf4c1ba9c5daa7928e" title="Returns the initialization type of the first row.">IManager::getFirstRowInitType()</a>  <a href="#a2ab4132fcf3c30fd649a44eae598abb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d">receiveFirstRow</a> (<a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a28dced18e7501938d924591c2ee47a81" title="Receives the first row of the partition.">IManager::receiveFirstRow()</a>  <a href="#a3b0b4d7e643f8d58a8887593070d021d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6">receiveFirstColumn</a> (<a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#ab3b54a8cb5971d1c1ad1937192de0c96" title="Receives the first column of the partition.">IManager::receiveFirstColumn()</a>  <a href="#a5826f966c44d93208b7b8da6763f3eb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a2816e1a632ea9739497ad1298b9348d7">dispatchColumn</a> (int j, const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#add1d39604472d166b32e5828b8beb3ca" title="Notifies to the MASA framework that some cells of a column has been processed.">IManager::dispatchColumn()</a>  <a href="#a2816e1a632ea9739497ad1298b9348d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#afd41f4b27ddd415d1cb8ab1318d8be17">dispatchRow</a> (int i, const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a72c77606165f415a230d4606cdfa407d" title="Notifies to the MASA framework that some cells of a row has been processed.">IManager::dispatchRow()</a>  <a href="#afd41f4b27ddd415d1cb8ab1318d8be17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#abb033d4cb32f8ab42e2ca5d6bbdf9117">dispatchScore</a> (<a class="el" href="structscore__t.html">score_t</a> score, int bx=-1, int by=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a400b8952cf59c23d9b0cdc92cfd51b3e" title="Notifies to the MASA framework that a new score has been computed.">IManager::dispatchScore()</a>  <a href="#abb033d4cb32f8ab42e2ca5d6bbdf9117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#ac00d50ea3dcb969c622c8fe2d6ac0160">mustContinue</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#ac62975691de49a590609d704f142f296">IManager::mustContinue()</a>  <a href="#ac00d50ea3dcb969c622c8fe2d6ac0160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a6da1710fd04090479af9f24a914c8218">mustDispatchLastCell</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a8f610b4b910c5e34fdf96a5001ebcdec">IManager::mustDispatchLastCell()</a>  <a href="#a6da1710fd04090479af9f24a914c8218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a583a16cd2ee6415b76b41839dc00be60">mustDispatchLastRow</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a322c0655e762bb1bdf608cb53c993d89">IManager::mustDispatchLastRow()</a>  <a href="#a583a16cd2ee6415b76b41839dc00be60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a93948e510ed96e7f0480275cafd423a8">mustDispatchLastColumn</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#ab7dd86bcf073d6cb5e8560e67dd3b254">IManager::mustDispatchLastColumn()</a>  <a href="#a93948e510ed96e7f0480275cafd423a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#add63e462d1cb771332ff70794af6db64">mustDispatchSpecialRows</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a63ff7e11c9cb09452340b97dce07eff5">IManager::mustDispatchSpecialRows()</a>  <a href="#add63e462d1cb771332ff70794af6db64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a172e61bae05e0a0a7b84d34dba7dc220">mustDispatchSpecialColumns</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#a0f121b6ad20a67c2dbfdd6ab0267f11b">IManager::mustDispatchSpecialColumns()</a>  <a href="#a172e61bae05e0a0a7b84d34dba7dc220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a568cdc885f97ee5e6f5f219300c71e65">mustDispatchScores</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#af803f6b9d43564cc66e8c23b886bb41c">IManager::mustDispatchScores()</a>  <a href="#a568cdc885f97ee5e6f5f219300c71e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#ac2ca4fbe023f36985d5bfcc5c9a8cd93">mustPruneBlocks</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegates to <a class="el" href="classIManager.html#ae9248a331ce802360d55d61a849a3f72">IManager::mustPruneBlocks()</a>  <a href="#ac2ca4fbe023f36985d5bfcc5c9a8cd93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcell__t.html">cell_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a3e3481cc1165a604d7cb4a1f2c00235a">getFirstColumnTail</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcell__t.html">cell_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#ae0ad0b613030f3fceeb32c40a6d70d5f">getFirstRowTail</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIManager.html">IManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#ad95eca23ac415a19981aae2b7f53875a">manager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager object that receives calls from Aligner to MASA-Core.  <a href="#ad95eca23ac415a19981aae2b7f53875a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a7564052368b750d0637c97b5fedc3aab">forkWeights</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The computational power weights of each forked processes.  <a href="#a7564052368b750d0637c97b5fedc3aab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#acde0822aad9e8fe78a5def1006a8ab2b">forkCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of forked proceess.  <a href="#acde0822aad9e8fe78a5def1006a8ab2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrid.html">Grid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#aca1c60bfe8e3fa3bce1984d818f93fbb">grid</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The processing grid.  <a href="#aca1c60bfe8e3fa3bce1984d818f93fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcell__t.html">cell_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a2884a2fcf0ff103c62473d92b6d37a0f">firstColumnTail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last cell read in the first column.  <a href="#a2884a2fcf0ff103c62473d92b6d37a0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcell__t.html">cell_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAligner.html#a8bedbdd763e2a714351f39889894c9d9">firstRowTail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last cell read in the first row.  <a href="#a8bedbdd763e2a714351f39889894c9d9"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af707917b2e834117c777af6c8f9656e1"></a><!-- doxytag: member="AbstractAligner::AbstractAligner" ref="af707917b2e834117c777af6c8f9656e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstractAligner.html#af707917b2e834117c777af6c8f9656e1">AbstractAligner::AbstractAligner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> contructor. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00033">33</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac18a90717146f8c859cfa9af77ce89bc"></a><!-- doxytag: member="AbstractAligner::~AbstractAligner" ref="ac18a90717146f8c859cfa9af77ce89bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstractAligner.html#ac18a90717146f8c859cfa9af77ce89bc">AbstractAligner::~AbstractAligner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> destructor. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00048">48</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a10740e19e79a256a6e8459b43bf8b30d"></a><!-- doxytag: member="AbstractAligner::createGrid" ref="a10740e19e79a256a6e8459b43bf8b30d" args="(Partition partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrid.html">Grid</a> * <a class="el" href="classAbstractAligner.html#a10740e19e79a256a6e8459b43bf8b30d">AbstractAligner::createGrid</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a>&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new grid using the given partition coordinates. </p>
<p>If there is a previously created grid, it is deleted and overwritten.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>the partition to be split in a grid of blocks. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00106">106</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2816e1a632ea9739497ad1298b9348d7"></a><!-- doxytag: member="AbstractAligner::dispatchColumn" ref="a2816e1a632ea9739497ad1298b9348d7" args="(int j, const cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#a2816e1a632ea9739497ad1298b9348d7">AbstractAligner::dispatchColumn</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#add1d39604472d166b32e5828b8beb3ca" title="Notifies to the MASA framework that some cells of a column has been processed.">IManager::dispatchColumn()</a> </p>
<p>Notifies to the MASA framework that some cells of a column has been processed. </p>
<p>This function must be called serially for each column. For example, the invocation of dispatchColumn(50000, vector, 100) will dispatch the first 100 cells of the column 50000 to MASA, and the cells are read from the vector[0..99] elements. After this, a call to dispatchColumn(50000, vector, 50) will dispatch the next 50 cells of the same column 5000, and the cells are read from the vector[0..49] elements.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>the column to be dispatched. </td></tr>
    <tr><td class="paramname">buffer</td><td>the vector containing the data (starting from cell 0). </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read from the vector. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#add1d39604472d166b32e5828b8beb3ca" title="Notifies to the MASA framework that some cells of a column has been processed.">IManager::dispatchColumn()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractAlignerSafe.html#acee981842ab70429bb0535946238c515">AbstractAlignerSafe</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00246">246</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd41f4b27ddd415d1cb8ab1318d8be17"></a><!-- doxytag: member="AbstractAligner::dispatchRow" ref="afd41f4b27ddd415d1cb8ab1318d8be17" args="(int i, const cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#afd41f4b27ddd415d1cb8ab1318d8be17">AbstractAligner::dispatchRow</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a72c77606165f415a230d4606cdfa407d" title="Notifies to the MASA framework that some cells of a row has been processed.">IManager::dispatchRow()</a> </p>
<p>Notifies to the MASA framework that some cells of a row has been processed. </p>
<p>This function must be called serially for each row, analogous to the AbstractAligner::dispatchLastColumn method.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row to be dispatched. </td></tr>
    <tr><td class="paramname">buffer</td><td>the vector containing the data (starting from cell 0). </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read from the vector. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a72c77606165f415a230d4606cdfa407d" title="Notifies to the MASA framework that some cells of a row has been processed.">IManager::dispatchRow()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractAlignerSafe.html#af2c63c9821f7440c06954d339725023f">AbstractAlignerSafe</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00254">254</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb033d4cb32f8ab42e2ca5d6bbdf9117"></a><!-- doxytag: member="AbstractAligner::dispatchScore" ref="abb033d4cb32f8ab42e2ca5d6bbdf9117" args="(score_t score, int bx=&#45;1, int by=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#abb033d4cb32f8ab42e2ca5d6bbdf9117">AbstractAligner::dispatchScore</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscore__t.html">score_t</a>&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bx</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a400b8952cf59c23d9b0cdc92cfd51b3e" title="Notifies to the MASA framework that a new score has been computed.">IManager::dispatchScore()</a> </p>
<p>Notifies to the MASA framework that a new score has been computed. </p>
<p>This method may be called as many times it is necessary, and the best score will be calculated among all calls of this method.</p>
<p>If the Aligner supports the <a class="el" href="structaligner__capabilities__t.html#a6894b92fb6480c2cfe920f38f312a95e" title="Dispatches scores in a regular block pattern.">aligner_capabilities_t::dispatch_block_scores</a> capability, them it must dispatch the score with the bx, by parameters set to the block indices and this method must be called only once for each block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">score</td><td>the score to be dispatched </td></tr>
    <tr><td class="paramname">bx</td><td>the block position in the horizontal direction, starting from 0 up to AbstractAligner::getGridWidth() minus 1. </td></tr>
    <tr><td class="paramname">by</td><td>the block position in the vertical direction, starting from 0 up to AbstractAligner::getGridHeight() minus 1. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a400b8952cf59c23d9b0cdc92cfd51b3e" title="Notifies to the MASA framework that a new score has been computed.">IManager::dispatchScore()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classAbstractAlignerSafe.html#a648ac50cc49570b69eeb4db01025fda7">AbstractAlignerSafe</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00262">262</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4af4756383624780721d22c831e6bca9"></a><!-- doxytag: member="AbstractAligner::getFirstColumnInitType" ref="a4af4756383624780721d22c831e6bca9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAbstractAligner.html#a4af4756383624780721d22c831e6bca9">AbstractAligner::getFirstColumnInitType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#ae89c12af219f421da96c1ac22af01ea5" title="Returns the initialization type of the first column.">IManager::getFirstColumnInitType()</a> </p>
<p>Returns the initialization type of the first column. </p>
<p>Possible values are </p>
<ul>
<li>
<p class="startli">INIT_WITH_CUSTOM_DATA: the first column must be initialized with custom data that can only be obtained by the <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6" title="Delegates to IManager::receiveFirstColumn()">AbstractAligner::receiveFirstColumn</a> method. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS: the first column must be initialized considering gaps. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,0} &amp;=&amp; 0 \\ H_{k,0} &amp;=&amp; -k.G_{ext}-G_{open} \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_13.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS_OPENED: the first column must be initialized considering gaps, but without gap opening penalty. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{k,0} &amp;=&amp; -k.G_{ext} \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_14.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_ZEROES: the first column must be initialized considering zero values. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{k,0} &amp;=&amp; 0 \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_15.png"/>
</p>
 <p>The initialization data of all types may be obtained by the <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6" title="Delegates to IManager::receiveFirstColumn()">AbstractAligner::receiveFirstColumn</a> method, but the subclass of <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> may implement the initialization functions using some architectural dependent code (for example, using vectorial hardware instructions).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the initialization type. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#ae89c12af219f421da96c1ac22af01ea5" title="Returns the initialization type of the first column.">IManager::getFirstColumnInitType()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00211">211</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e3481cc1165a604d7cb4a1f2c00235a"></a><!-- doxytag: member="AbstractAligner::getFirstColumnTail" ref="a3e3481cc1165a604d7cb4a1f2c00235a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcell__t.html">cell_t</a> <a class="el" href="classAbstractAligner.html#a3e3481cc1165a604d7cb4a1f2c00235a">AbstractAligner::getFirstColumnTail</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the last cell read from the first column </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00333">333</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ab4132fcf3c30fd649a44eae598abb9"></a><!-- doxytag: member="AbstractAligner::getFirstRowInitType" ref="a2ab4132fcf3c30fd649a44eae598abb9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAbstractAligner.html#a2ab4132fcf3c30fd649a44eae598abb9">AbstractAligner::getFirstRowInitType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a41254fba0cfeccbf4c1ba9c5daa7928e" title="Returns the initialization type of the first row.">IManager::getFirstRowInitType()</a> </p>
<p>Returns the initialization type of the first row. </p>
<p>Possible values are </p>
<ul>
<li>
<p class="startli">INIT_WITH_CUSTOM_DATA: the first row must be initialized with custom data that can only be obtained by the <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d" title="Delegates to IManager::receiveFirstRow()">AbstractAligner::receiveFirstRow</a> method. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS: the first column must be initialized considering gaps. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,0} &amp;=&amp; 0 \\ H_{0,k} &amp;=&amp; -k.G_{ext}-G_{open} \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_16.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS_OPENED: the first column must be initialized considering gaps, but without gap opening penalty. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,k} &amp;=&amp; -k.G_{ext} \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_17.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_ZEROES: the first row must be initialized considering zero values. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,k} &amp;=&amp; 0 \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_18.png"/>
</p>
 <p>The initialization data of all types may be obtained by the <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d" title="Delegates to IManager::receiveFirstRow()">AbstractAligner::receiveFirstRow</a> method, but the subclass of <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> may implement the initialization functions using some architectural dependent code (for example, using vectorial hardware instructions).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the initialization type. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a41254fba0cfeccbf4c1ba9c5daa7928e" title="Returns the initialization type of the first row.">IManager::getFirstRowInitType()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00219">219</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0ad0b613030f3fceeb32c40a6d70d5f"></a><!-- doxytag: member="AbstractAligner::getFirstRowTail" ref="ae0ad0b613030f3fceeb32c40a6d70d5f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcell__t.html">cell_t</a> <a class="el" href="classAbstractAligner.html#ae0ad0b613030f3fceeb32c40a6d70d5f">AbstractAligner::getFirstRowTail</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the last cell read from the first row </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00340">340</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18b6ce3477f0b4a5bbbe108e42aadae9"></a><!-- doxytag: member="AbstractAligner::getForkWeights" ref="a18b6ce3477f0b4a5bbbe108e42aadae9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int * <a class="el" href="classAbstractAligner.html#a18b6ce3477f0b4a5bbbe108e42aadae9">AbstractAligner::getForkWeights</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supply the computational power weight defined after the <a class="el" href="classAbstractAligner.html#a15085bdaa0b4f829a34db0b5dd55e202" title="Defines how many processes may be forked for this aligner and the computation weight for each process...">AbstractAligner::setForkCount</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the weights for each process. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIAligner.html#abbd463afa95aeb659067ec8c04c13e8c" title="Supply the computational power weight of each forked processed.">IAligner::getForkWeights()</a> </dd></dl>

<p>Implements <a class="el" href="classIAligner.html#abbd463afa95aeb659067ec8c04c13e8c">IAligner</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00096">96</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3448cc3cba9423a8758f4d677eac67e5"></a><!-- doxytag: member="AbstractAligner::getGrid" ref="a3448cc3cba9423a8758f4d677eac67e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGrid.html">Grid</a> * <a class="el" href="classAbstractAligner.html#a3448cc3cba9423a8758f4d677eac67e5">AbstractAligner::getGrid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the grid created by the last call to the <a class="el" href="classAbstractAligner.html#a10740e19e79a256a6e8459b43bf8b30d" title="Creates a new grid using the given partition coordinates.">AbstractAligner::createGrid</a> method. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current grid object. </dd></dl>

<p>Implements <a class="el" href="classIAligner.html#aa7f42942f0c27989501ec3e72d9b693d">IAligner</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00121">121</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afacbcb609bbb6d8ebcaafaec73e262af"></a><!-- doxytag: member="AbstractAligner::getRecurrenceType" ref="afacbcb609bbb6d8ebcaafaec73e262af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAbstractAligner.html#afacbcb609bbb6d8ebcaafaec73e262af">AbstractAligner::getRecurrenceType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a1e389d0cf094847cc91b98dd22a155de">IManager::getRecurrenceType()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the recurrence type of the alignment. Possible values are SMITH_WATERMAN and NEEDLEMAN_WUNSCH. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a1e389d0cf094847cc91b98dd22a155de">IManager::getRecurrenceType()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00179">179</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24722d7768fec9ff4baac7fe1dd1185a"></a><!-- doxytag: member="AbstractAligner::getSpecialColumnInterval" ref="a24722d7768fec9ff4baac7fe1dd1185a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAbstractAligner.html#a24722d7768fec9ff4baac7fe1dd1185a">AbstractAligner::getSpecialColumnInterval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a8c60a1269909d9388627063d5b48eaef">IManager::getSpecialColumnInterval()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum distance between two special columns, or 0 if it must not save special columns. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a8c60a1269909d9388627063d5b48eaef">IManager::getSpecialColumnInterval()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00195">195</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1446002ca4fe9bfb0ff89983878b46e3"></a><!-- doxytag: member="AbstractAligner::getSpecialRowInterval" ref="a1446002ca4fe9bfb0ff89983878b46e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAbstractAligner.html#a1446002ca4fe9bfb0ff89983878b46e3">AbstractAligner::getSpecialRowInterval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a982e656c11981976af06d53eddb205f8">IManager::getSpecialRowInterval()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum distance between two special rows, or 0 if it must not save special rows. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a982e656c11981976af06d53eddb205f8">IManager::getSpecialRowInterval()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00187">187</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38dedb2033c512acd64f544bd0b26a9d"></a><!-- doxytag: member="AbstractAligner::getSuperPartition" ref="a38dedb2033c512acd64f544bd0b26a9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition.html">Partition</a> <a class="el" href="classAbstractAligner.html#a38dedb2033c512acd64f544bd0b26a9d">AbstractAligner::getSuperPartition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d" title="Returns the super partition that includes all sub partitions being aligned.">IManager::getSuperPartition()</a> </p>
<p>Returns the super partition that includes all sub partitions being aligned. </p>
<p>This method must be used only by block pruning algorithms in order to obtain the corner coordinates of the matrix.</p>
<p>A super partition is a set of many smaller partitions and this occurs in two situations. The first is when we are running stage1 in a multiprocess environment, where we have one sub partition for each process. The second situation happens when the aligner cannot handle the full size of the matrix, so the partition is split in parts smaller than the max sequence size capability of the aligner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the super partition. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d" title="Returns the super partition that includes all sub partitions being aligned.">IManager::getSuperPartition()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00203">203</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac731ae81af1b2040bc2324e114df426f"></a><!-- doxytag: member="AbstractAligner::initializeBlockPruning" ref="ac731ae81af1b2040bc2324e114df426f" args="(AbstractBlockPruning *blockPruner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#ac731ae81af1b2040bc2324e114df426f">AbstractAligner::initializeBlockPruning</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAbstractBlockPruning.html">AbstractBlockPruning</a> *&#160;</td>
          <td class="paramname"><em>blockPruner</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the pruner object. </p>
<p>It must be called after the grid is created by the <a class="el" href="classAbstractAligner.html#a10740e19e79a256a6e8459b43bf8b30d" title="Creates a new grid using the given partition coordinates.">AbstractAligner::createGrid</a> method.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">blockPruner</td><td>the pruner object to be initialized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00131">131</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a255fbe4d8b8727ff0b536df6cbf9a473"></a><!-- doxytag: member="AbstractAligner::matchLastColumn" ref="a255fbe4d8b8727ff0b536df6cbf9a473" args="(const cell_t *buffer, const cell_t *base, int len, int goalScore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatch__result__t.html">match_result_t</a> <a class="el" href="classAbstractAligner.html#a255fbe4d8b8727ff0b536df6cbf9a473">AbstractAligner::matchLastColumn</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>goalScore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the matching procedure in CPU. </p>
<p>This method is a default implementation that works in any condition, but a subclass may override it in order to create a faster matching procedure for the MASA extension.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector with the last column data. </td></tr>
    <tr><td class="paramname">base</td><td>the vector with the special row in the reverse direction. </td></tr>
    <tr><td class="paramname">len</td><td>Defines that we must match the buffers in the range [0,len). </td></tr>
    <tr><td class="paramname">goalScore</td><td>the score that will be searched during the matching procedure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the match result. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIAligner.html#a3b477423cd00dd49c7aceea9902ffdb7" title="This method executes the Myers-Miller matching procedure.">IAligner::matchLastColumn</a> for a better explanation of the parameters. </dd></dl>

<p>Implements <a class="el" href="classIAligner.html#a3b477423cd00dd49c7aceea9902ffdb7">IAligner</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00158">158</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac00d50ea3dcb969c622c8fe2d6ac0160"></a><!-- doxytag: member="AbstractAligner::mustContinue" ref="ac00d50ea3dcb969c622c8fe2d6ac0160" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#ac00d50ea3dcb969c622c8fe2d6ac0160">AbstractAligner::mustContinue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#ac62975691de49a590609d704f142f296">IManager::mustContinue()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the execution must continue. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#ac62975691de49a590609d704f142f296">IManager::mustContinue()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00270">270</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6da1710fd04090479af9f24a914c8218"></a><!-- doxytag: member="AbstractAligner::mustDispatchLastCell" ref="a6da1710fd04090479af9f24a914c8218" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#a6da1710fd04090479af9f24a914c8218">AbstractAligner::mustDispatchLastCell</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a8f610b4b910c5e34fdf96a5001ebcdec">IManager::mustDispatchLastCell()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last cell must be dispatched. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a8f610b4b910c5e34fdf96a5001ebcdec">IManager::mustDispatchLastCell()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00278">278</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93948e510ed96e7f0480275cafd423a8"></a><!-- doxytag: member="AbstractAligner::mustDispatchLastColumn" ref="a93948e510ed96e7f0480275cafd423a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#a93948e510ed96e7f0480275cafd423a8">AbstractAligner::mustDispatchLastColumn</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#ab7dd86bcf073d6cb5e8560e67dd3b254">IManager::mustDispatchLastColumn()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last column must be dispatched. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#ab7dd86bcf073d6cb5e8560e67dd3b254">IManager::mustDispatchLastColumn()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00294">294</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a583a16cd2ee6415b76b41839dc00be60"></a><!-- doxytag: member="AbstractAligner::mustDispatchLastRow" ref="a583a16cd2ee6415b76b41839dc00be60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#a583a16cd2ee6415b76b41839dc00be60">AbstractAligner::mustDispatchLastRow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a322c0655e762bb1bdf608cb53c993d89">IManager::mustDispatchLastRow()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last row must be dispatched. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a322c0655e762bb1bdf608cb53c993d89">IManager::mustDispatchLastRow()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00286">286</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a568cdc885f97ee5e6f5f219300c71e65"></a><!-- doxytag: member="AbstractAligner::mustDispatchScores" ref="a568cdc885f97ee5e6f5f219300c71e65" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#a568cdc885f97ee5e6f5f219300c71e65">AbstractAligner::mustDispatchScores</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#af803f6b9d43564cc66e8c23b886bb41c">IManager::mustDispatchScores()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if intermediate scores must be dispatched. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#af803f6b9d43564cc66e8c23b886bb41c">IManager::mustDispatchScores()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00310">310</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a172e61bae05e0a0a7b84d34dba7dc220"></a><!-- doxytag: member="AbstractAligner::mustDispatchSpecialColumns" ref="a172e61bae05e0a0a7b84d34dba7dc220" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#a172e61bae05e0a0a7b84d34dba7dc220">AbstractAligner::mustDispatchSpecialColumns</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a0f121b6ad20a67c2dbfdd6ab0267f11b">IManager::mustDispatchSpecialColumns()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if special columns must be dispatched. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a0f121b6ad20a67c2dbfdd6ab0267f11b">IManager::mustDispatchSpecialColumns()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00318">318</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="add63e462d1cb771332ff70794af6db64"></a><!-- doxytag: member="AbstractAligner::mustDispatchSpecialRows" ref="add63e462d1cb771332ff70794af6db64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#add63e462d1cb771332ff70794af6db64">AbstractAligner::mustDispatchSpecialRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a63ff7e11c9cb09452340b97dce07eff5">IManager::mustDispatchSpecialRows()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if special rows must be dispatched. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a63ff7e11c9cb09452340b97dce07eff5">IManager::mustDispatchSpecialRows()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00302">302</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2ca4fbe023f36985d5bfcc5c9a8cd93"></a><!-- doxytag: member="AbstractAligner::mustPruneBlocks" ref="ac2ca4fbe023f36985d5bfcc5c9a8cd93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractAligner.html#ac2ca4fbe023f36985d5bfcc5c9a8cd93">AbstractAligner::mustPruneBlocks</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#ae9248a331ce802360d55d61a849a3f72">IManager::mustPruneBlocks()</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if block pruning optimization may be used. </dd></dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#ae9248a331ce802360d55d61a849a3f72">IManager::mustPruneBlocks()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00326">326</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5826f966c44d93208b7b8da6763f3eb6"></a><!-- doxytag: member="AbstractAligner::receiveFirstColumn" ref="a5826f966c44d93208b7b8da6763f3eb6" args="(cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6">AbstractAligner::receiveFirstColumn</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#ab3b54a8cb5971d1c1ad1937192de0c96" title="Receives the first column of the partition.">IManager::receiveFirstColumn()</a> </p>
<p>Receives the first column of the partition. </p>
<p>This function may block until all the requested data is ready. So prefer to read data in chunks instead of reading the full first row. The data will be stored from 0 to len-1 positions of the vector passed in the parameters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector where the first column data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#ab3b54a8cb5971d1c1ad1937192de0c96" title="Receives the first column of the partition.">IManager::receiveFirstColumn()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00236">236</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b0b4d7e643f8d58a8887593070d021d"></a><!-- doxytag: member="AbstractAligner::receiveFirstRow" ref="a3b0b4d7e643f8d58a8887593070d021d" args="(cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d">AbstractAligner::receiveFirstRow</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delegates to <a class="el" href="classIManager.html#a28dced18e7501938d924591c2ee47a81" title="Receives the first row of the partition.">IManager::receiveFirstRow()</a> </p>
<p>Receives the first row of the partition. </p>
<p>This function may block until all the requested data is ready. So prefer to read data in chunks instead of reading the full first row. The data will be stored from 0 to len-1 positions of the vector passed in the parameters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector where the first row data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read. </td></tr>
  </table>
  </dd>
</dl>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a28dced18e7501938d924591c2ee47a81" title="Receives the first row of the partition.">IManager::receiveFirstRow()</a> </dd></dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00227">227</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15085bdaa0b4f829a34db0b5dd55e202"></a><!-- doxytag: member="AbstractAligner::setForkCount" ref="a15085bdaa0b4f829a34db0b5dd55e202" args="(const int forkCount, const int *forkWeights=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#a15085bdaa0b4f829a34db0b5dd55e202">AbstractAligner::setForkCount</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>forkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>forkWeights</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines how many processes may be forked for this aligner and the computation weight for each process. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">forkCount</td><td>number of processes allowed. </td></tr>
    <tr><td class="paramname">forkWeights</td><td>vector containing $forkCount$ weights. If NULL, all the processes will have the same weight. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00071">71</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69671d1a0c95a8c6263d79c489dd5354"></a><!-- doxytag: member="AbstractAligner::setManager" ref="a69671d1a0c95a8c6263d79c489dd5354" args="(IManager *manager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAligner.html#a69671d1a0c95a8c6263d79c489dd5354">AbstractAligner::setManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIManager.html">IManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the <a class="el" href="classIManager.html" title="Interface that manages the MASA extension execution.">IManager</a> to be associated with this aligner. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>the interface to the MASA-Core. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIAligner.html#a2d4eee6a87108d2d2dacf1e2a3c567fb">IAligner</a>.</p>

<p>Definition at line <a class="el" href="AbstractAligner_8cpp_source.html#l00059">59</a> of file <a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2884a2fcf0ff103c62473d92b6d37a0f"></a><!-- doxytag: member="AbstractAligner::firstColumnTail" ref="a2884a2fcf0ff103c62473d92b6d37a0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcell__t.html">cell_t</a> <a class="el" href="classAbstractAligner.html#a2884a2fcf0ff103c62473d92b6d37a0f">AbstractAligner::firstColumnTail</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Last cell read in the first column. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00127">127</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bedbdd763e2a714351f39889894c9d9"></a><!-- doxytag: member="AbstractAligner::firstRowTail" ref="a8bedbdd763e2a714351f39889894c9d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcell__t.html">cell_t</a> <a class="el" href="classAbstractAligner.html#a8bedbdd763e2a714351f39889894c9d9">AbstractAligner::firstRowTail</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Last cell read in the first row. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00130">130</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acde0822aad9e8fe78a5def1006a8ab2b"></a><!-- doxytag: member="AbstractAligner::forkCount" ref="acde0822aad9e8fe78a5def1006a8ab2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAbstractAligner.html#acde0822aad9e8fe78a5def1006a8ab2b">AbstractAligner::forkCount</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of forked proceess. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00121">121</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7564052368b750d0637c97b5fedc3aab"></a><!-- doxytag: member="AbstractAligner::forkWeights" ref="a7564052368b750d0637c97b5fedc3aab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classAbstractAligner.html#a7564052368b750d0637c97b5fedc3aab">AbstractAligner::forkWeights</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The computational power weights of each forked processes. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00118">118</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca1c60bfe8e3fa3bce1984d818f93fbb"></a><!-- doxytag: member="AbstractAligner::grid" ref="aca1c60bfe8e3fa3bce1984d818f93fbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrid.html">Grid</a>* <a class="el" href="classAbstractAligner.html#aca1c60bfe8e3fa3bce1984d818f93fbb">AbstractAligner::grid</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The processing grid. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00124">124</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad95eca23ac415a19981aae2b7f53875a"></a><!-- doxytag: member="AbstractAligner::manager" ref="ad95eca23ac415a19981aae2b7f53875a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIManager.html">IManager</a>* <a class="el" href="classAbstractAligner.html#ad95eca23ac415a19981aae2b7f53875a">AbstractAligner::manager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manager object that receives calls from Aligner to MASA-Core. </p>

<p>Definition at line <a class="el" href="AbstractAligner_8hpp_source.html#l00115">115</a> of file <a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="AbstractAligner_8hpp_source.html">AbstractAligner.hpp</a></li>
<li><a class="el" href="AbstractAligner_8cpp_source.html">AbstractAligner.cpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri May 8 2015 11:39:21 for MASA-Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
