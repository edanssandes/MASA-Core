<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MASA-Core: AlignerManager Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MASA-Core
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">AlignerManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="AlignerManager" --><!-- doxytag: inherits="IManager" --><hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00041">41</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AlignerManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAlignerManager.png" usemap="#AlignerManager_map" alt=""/>
  <map id="AlignerManager_map" name="AlignerManager_map">
<area href="classIManager.html" title="Interface that manages the MASA extension execution." alt="IManager" shape="rect" coords="0,0,104,24"/>
</map>
 </div></div>

<p><a href="classAlignerManager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a4b3c4eec965e0366b27f0b1de4eaf18e">AlignerManager</a> (<a class="el" href="classIAligner.html">IAligner</a> *<a class="el" href="classAlignerManager.html#accb5b17e676541385aff9852cb0da086">aligner</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a74e366fb5475e68974172b199e433249">~AlignerManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a5e8d4fba1a6db77782e6cd3b7e392f39">alignPartition</a> (<a class="el" href="classPartition.html">Partition</a> <a class="el" href="classAlignerManager.html#a0dfd7b941d6cb6eab1518a5890fd2aad">partition</a>, int <a class="el" href="classAlignerManager.html#ac5dbca34b32c275a859a21838e02c6cc">startType</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aa73b698b5abdb5e51fc6dd02dc96c0b7">setSequences</a> (<a class="el" href="classSequence.html">Sequence</a> *seq0, <a class="el" href="classSequence.html">Sequence</a> *seq1, int i0, int j0, int i1, int j1, FILE *stats=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the partition that must be processed.  <a href="#aa73b698b5abdb5e51fc6dd02dc96c0b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a1f687a923143258bf8959a411c815205">unsetSequences</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all sequence strucutures.  <a href="#a1f687a923143258bf8959a411c815205"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a8943fd323d361c786bc48dec34f3486c">setRecurrenceType</a> (int <a class="el" href="classAlignerManager.html#a6836950e521154fd4ec97fddadf2ec8a">recurrenceType</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines that the first column must be initialized with a pre-defined column.  <a href="#a8943fd323d361c786bc48dec34f3486c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a251c7f794ebb23101e3c5dd218fed50d">setBlockPruning</a> (bool <a class="el" href="classAlignerManager.html#ad3c61a7000db68aebfe7f29f4d415431">blockPruning</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines if the aligner may do the block pruning optimization.  <a href="#a251c7f794ebb23101e3c5dd218fed50d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ad8acb8834b8bbed891b5761472d4ad32">setSpecialRowsPartition</a> (<a class="el" href="classSpecialRowsPartition.html">SpecialRowsPartition</a> *<a class="el" href="classAlignerManager.html#a61fe1518cbeb790cc89625a5fc9b46a1">specialRowsPartition</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the grid dimension of the grid, if capabilities_t::dispatch_block_scores is SUPPORTED.  <a href="#ad8acb8834b8bbed891b5761472d4ad32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a8d3d7a8623943bed310e5ea627d8788f">setBestScoreList</a> (<a class="el" href="classBestScoreList.html">BestScoreList</a> *<a class="el" href="classAlignerManager.html#a96256feafe27cbe8edf7bfeffbaa2402">bestScoreList</a>, const int <a class="el" href="classAlignerManager.html#a1081926183696243fb9ffa34b005b46e">bestScoreLocation</a>=<a class="el" href="Job_8hpp.html#aaa2ec5091c90242236244232f10e3aa8">AT_NOWHERE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the list to store the best scores.  <a href="#a8d3d7a8623943bed310e5ea627d8788f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#af22b2bade8c6bd56fe2a6ef9e3333e85">setGoalScore</a> (int <a class="el" href="classAlignerManager.html#aa1f57b3b06b31a72a043ab67cc376bc0">goalScore</a>, const int <a class="el" href="classAlignerManager.html#ab03e4bd168f79541f7feb22a751d2657">goalScoreLocation</a>=<a class="el" href="Job_8hpp.html#aaa2ec5091c90242236244232f10e3aa8">AT_NOWHERE</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whenever the aligner finds the goal score, the processing must stop.  <a href="#af22b2bade8c6bd56fe2a6ef9e3333e85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ab72ef729993a9effab3e0a99a86f9340">setLastColumnReader</a> (<a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *<a class="el" href="classAlignerManager.html#aec69ec1a443e891d3348319e6c3975c6">lastColumnReader</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the previous special rows partition containing the rows to be matched against the last column/rows.  <a href="#ab72ef729993a9effab3e0a99a86f9340"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a548c0ccac9a734cb7e30b8b059e877cf">setLastRowReader</a> (<a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *<a class="el" href="classAlignerManager.html#aebd2ce79f17b5f9dc9f88d79ed9234b3">lastRowReader</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the previous special rows partition containing the rows to be matched against the last column/rows.  <a href="#a548c0ccac9a734cb7e30b8b059e877cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a486fa727f81bc7733cc05ba136329411">unsetGoalScore</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not find best score.  <a href="#a486fa727f81bc7733cc05ba136329411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a42a650ee90529c4379c517df3e801541">setBlocksFile</a> (<a class="el" href="classBlocksFile.html">BlocksFile</a> *<a class="el" href="classAlignerManager.html#a32cf9aa11a2c8840798df9f724f3e9e9">blocksFile</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the file to store the best score of each block.  <a href="#a42a650ee90529c4379c517df3e801541"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aeff103ccc690b0a9e9c4d488e4584ed4">setSpecialRowInterval</a> (const int <a class="el" href="classAlignerManager.html#a6ed63fbbf32bc7f0b51a18fa820f1f47">specialRowInterval</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the minimum distance (in rows) between two special rows.  <a href="#aeff103ccc690b0a9e9c4d488e4584ed4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a1785552dd5f9a07ed425ea6701714b11">setPenalties</a> (const int <a class="el" href="classAlignerManager.html#af854877ee7c0e69746533ad5ba910d15">match</a>, const int <a class="el" href="classAlignerManager.html#a741dd13bf1725aa0248d2774fb03b95f">mismatch</a>, const int <a class="el" href="classAlignerManager.html#a35a9f948020f4996bc0c07aba10a6753">gapOpen</a>, const int <a class="el" href="classAlignerManager.html#a738bb13a928ed3c35a2753e11cf3992f">gapExtension</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the variable penalty functions to be aligned.  <a href="#a1785552dd5f9a07ed425ea6701714b11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a4f961cf23649cdca51a7901e006a9af3">setSuperPartition</a> (<a class="el" href="classPartition.html">Partition</a> <a class="el" href="classAlignerManager.html#a868a3ab5c9158c234d31a236ce7c9d4b">superPartition</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the super-partition being aligned to be returned by the <a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d" title="Returns the super partition that includes all sub partitions being aligned.">IManager::getSuperPartition()</a> method.  <a href="#a4f961cf23649cdca51a7901e006a9af3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a8bef05cdfe88c521e38ba41dfd1a2ccd">unsetSuperPartition</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the super-partition.  <a href="#a8bef05cdfe88c521e38ba41dfd1a2ccd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcrosspoint__t.html">crosspoint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a8f092338447c9ecb597ed3c8c6a5be7e">getNextCrosspoint</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the callback function that will be called whenever the dispatchRow method is called for the last row.  <a href="#a8f092338447c9ecb597ed3c8c6a5be7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a783a9731031b2536f3494bbbb4810f2e">isFoundCrosspoint</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the next crosspoint was found.  <a href="#a783a9731031b2536f3494bbbb4810f2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a9c223d348306015e09dc9e4514316ca1">getRecurrenceType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#afb5b19ee122a1896ae51b27974bf1a47">getSpecialRowInterval</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#adb3156c988845ca60ec8c8a72c85a6c9">getSpecialColumnInterval</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a743a9b05e455d0482dfffc7be6415922">getFirstColumnInitType</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the initialization type of the first column.  <a href="#a743a9b05e455d0482dfffc7be6415922"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a0383e253450267ff0eae9906235e12f8">getFirstRowInitType</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the initialization type of the first row.  <a href="#a0383e253450267ff0eae9906235e12f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#addab2775f67799bf337c277f36a67a63">getSuperPartition</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the super partition that includes all sub partitions being aligned.  <a href="#addab2775f67799bf337c277f36a67a63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a0a1995a17b6e9d85af9ebd2233d560c0">receiveFirstRow</a> (<a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the first row of the partition.  <a href="#a0a1995a17b6e9d85af9ebd2233d560c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a9594ac58132da5d5818bb1010fe22b48">receiveFirstColumn</a> (<a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the first column of the partition.  <a href="#a9594ac58132da5d5818bb1010fe22b48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a73d065da73a1865f0a6b1e2ff9768774">dispatchColumn</a> (int j, const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies to the MASA framework that some cells of a column has been processed.  <a href="#a73d065da73a1865f0a6b1e2ff9768774"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aa0ac0d35378c6a7fb3ebe60d72e26307">dispatchRow</a> (int i, const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies to the MASA framework that some cells of a row has been processed.  <a href="#aa0ac0d35378c6a7fb3ebe60d72e26307"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aa31b355182487edfc7097cc65a03a88f">dispatchScore</a> (<a class="el" href="structscore__t.html">score_t</a> score, int bx=-1, int by=-1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies to the MASA framework that a new score has been computed.  <a href="#aa31b355182487edfc7097cc65a03a88f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aee7de63878b30b0a9f2a2f785ad34dc9">mustContinue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a03ab541b69e2e75f66ed6028fa76e03f">mustDispatchLastCell</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a919abaad137497db239d61ac2befd89d">mustDispatchLastRow</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ac869efe60c1e770d7e4ff3c4b2cb21ea">mustDispatchLastColumn</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a4ef30369e3062bd038db5d1e523659cd">mustDispatchSpecialRows</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a5aee93cbff23e2ad92e53349563160e7">mustDispatchSpecialColumns</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a907ed1a569587588f20052b4120afb66">mustDispatchScores</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a34672d16562514529dbf75200f625fd2">mustPruneBlocks</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscore__t.html">score_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ab292711adc4a805fb744b7bd2d299e88">getBestScoreLastColumn</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscore__t.html">score_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a6c342affed4d58b3bd1ccde547b14bda">getBestScoreLastRow</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ab3525b0d0a5b5c5ab48ad60773a2f036">stopAligner</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the execution of the aligner.  <a href="#ab3525b0d0a5b5c5ab48ad60773a2f036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#abe43b2212ca01c212c42c1302c3b3532">findBestCell</a> (const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatch__result__t.html">match_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a2cb589a2bd2dd59348c4341740fbd7af">findGoalCell</a> (const <a class="el" href="structcell__t.html">cell_t</a> *buffer, <a class="el" href="structcell__t.html">cell_t</a> *base, int len, <a class="el" href="classCellsReader.html">CellsReader</a> *cellsReader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatch__result__t.html">match_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a7f6bfaeb630309dfac87eb3743c15897">findFullGap</a> (int len, bool openGap, <a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *cellsReader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a9f1eebb42a28a06980514602bab81dc6">setFirstColumnSource</a> (<a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *<a class="el" href="classAlignerManager.html#ac891b6675396606c5daea67541a87fc9">firstColumnReader</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines that the first column must be initialized with a customized column.  <a href="#a9f1eebb42a28a06980514602bab81dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a1f5b3c12f542a46aaa501fdfcd59d47b">setFirstRowSource</a> (<a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *<a class="el" href="classAlignerManager.html#ac891b6675396606c5daea67541a87fc9">firstColumnReader</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines that the first row must be initialized with a pre-defined row.  <a href="#a1f5b3c12f542a46aaa501fdfcd59d47b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a8a78615614a772bc27e46f1b30fea48a">setLastColumnDestination</a> (<a class="el" href="classCellsWriter.html">CellsWriter</a> *<a class="el" href="classAlignerManager.html#a679c45a0d31f4a27db61631dede99f73">lastColumnWriter</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the destination of the last column.  <a href="#a8a78615614a772bc27e46f1b30fea48a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aef82f6b927b4919caee5cb00ca400e47">setLastRowDestination</a> (<a class="el" href="classCellsWriter.html">CellsWriter</a> *<a class="el" href="classAlignerManager.html#a627fe61522e1f41d68ee5090f9c65b38">lastRowWriter</a>)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a3f0b8ba5b79fb03b71371ec417f57df0">active</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIAligner.html">IAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#accb5b17e676541385aff9852cb0da086">aligner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The aligner object that executes the SW computation.  <a href="#accb5b17e676541385aff9852cb0da086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a0dfd7b941d6cb6eab1518a5890fd2aad">partition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The partition that is being aligned.  <a href="#a0dfd7b941d6cb6eab1518a5890fd2aad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aec69ec1a443e891d3348319e6c3975c6">lastColumnReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The reader that provides the last column saved in memory/disk.  <a href="#aec69ec1a443e891d3348319e6c3975c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aebd2ce79f17b5f9dc9f88d79ed9234b3">lastRowReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The reader that provides the last rows saved in memory/disk.  <a href="#aebd2ce79f17b5f9dc9f88d79ed9234b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a4de31d2ee14231adfe162d31d2a0bf66">baseColumn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that store the temporary cells for the matching procedures.  <a href="#a4de31d2ee14231adfe162d31d2a0bf66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#abbfd473273bb90678aa6e8e59071cb8e">baseRow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector that store the temporary cells for the matching procedures.  <a href="#abbfd473273bb90678aa6e8e59071cb8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structscore__params__t.html">score_params_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a16cee18fd0a904ef5bd2ae426c5e9499">score_params</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Math/mismatch/gaps parameters.  <a href="#a16cee18fd0a904ef5bd2ae426c5e9499"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ac5dbca34b32c275a859a21838e02c6cc">startType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The start type of the partition.  <a href="#ac5dbca34b32c275a859a21838e02c6cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#af854877ee7c0e69746533ad5ba910d15">match</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Match Score.  <a href="#af854877ee7c0e69746533ad5ba910d15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a741dd13bf1725aa0248d2774fb03b95f">mismatch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mismatch Score.  <a href="#a741dd13bf1725aa0248d2774fb03b95f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a35a9f948020f4996bc0c07aba10a6753">gapOpen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gap opening penalty.  <a href="#a35a9f948020f4996bc0c07aba10a6753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a738bb13a928ed3c35a2753e11cf3992f">gapExtension</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gap extension penalty.  <a href="#a738bb13a928ed3c35a2753e11cf3992f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ac891b6675396606c5daea67541a87fc9">firstColumnReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First column blocking buffer.  <a href="#ac891b6675396606c5daea67541a87fc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#af138031e21d703e1cb99b3eb63876cb8">firstRowReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First row blocking buffer.  <a href="#af138031e21d703e1cb99b3eb63876cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellsWriter.html">CellsWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a679c45a0d31f4a27db61631dede99f73">lastColumnWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last column blocking buffer.  <a href="#a679c45a0d31f4a27db61631dede99f73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellsWriter.html">CellsWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a627fe61522e1f41d68ee5090f9c65b38">lastRowWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Last row blocking buffer.  <a href="#a627fe61522e1f41d68ee5090f9c65b38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpecialRowsPartition.html">SpecialRowsPartition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a61fe1518cbeb790cc89625a5fc9b46a1">specialRowsPartition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPartition.html">Partition</a> where the Special Rows are stored.  <a href="#a61fe1518cbeb790cc89625a5fc9b46a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBestScoreList.html">BestScoreList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a96256feafe27cbe8edf7bfeffbaa2402">bestScoreList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List with the best scores.  <a href="#a96256feafe27cbe8edf7bfeffbaa2402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#aa1f57b3b06b31a72a043ab67cc376bc0">goalScore</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The aligner must stop whenever it finds the goal score.  <a href="#aa1f57b3b06b31a72a043ab67cc376bc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ab03e4bd168f79541f7feb22a751d2657">goalScoreLocation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Where to check the goal score.  <a href="#ab03e4bd168f79541f7feb22a751d2657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a901ff6fc2788bb903264c043f7645088">foundCrosspoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the next crosspoint has already been found.  <a href="#a901ff6fc2788bb903264c043f7645088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcrosspoint__t.html">crosspoint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a60d4aaa07df4178f4dc68045c37964ba">nextCrosspoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The crosspoint found by the matching procedure or the goal score.  <a href="#a60d4aaa07df4178f4dc68045c37964ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlocksFile.html">BlocksFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a32cf9aa11a2c8840798df9f724f3e9e9">blocksFile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a1081926183696243fb9ffa34b005b46e">bestScoreLocation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Where to check best score.  <a href="#a1081926183696243fb9ffa34b005b46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a8651cb254f79c9521366e05ae98c7b8e">lastColumnPos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Column tracking position for the dispatching procedure.  <a href="#a8651cb254f79c9521366e05ae98c7b8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ab40581ae0aacc906b60898d3b70577d9">lastRowPos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Row tracking position for the dispatching procedure.  <a href="#ab40581ae0aacc906b60898d3b70577d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ad3c61a7000db68aebfe7f29f4d415431">blockPruning</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for the last rows.  <a href="#ad3c61a7000db68aebfe7f29f4d415431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a6836950e521154fd4ec97fddadf2ec8a">recurrenceType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">required recurrence type (SMITH_WATERMAN or NEEDLEMAN_WUNSCH)  <a href="#a6836950e521154fd4ec97fddadf2ec8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a6ed63fbbf32bc7f0b51a18fa820f1f47">specialRowInterval</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum distance between two special rows  <a href="#a6ed63fbbf32bc7f0b51a18fa820f1f47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a9a0c904d871fe2f9be118149d7dde3c6">firstRowFile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">File where the first row is stored.  <a href="#a9a0c904d871fe2f9be118149d7dde3c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a12acc9ba82b991e9b365d2b981d177a8">firstColumnInitType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First row tracking position for the receive procedure.  <a href="#a12acc9ba82b991e9b365d2b981d177a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a9c93b95fa2028a36c2fc39e004924a28">firstRowInitType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true if first row is gapped  <a href="#a9c93b95fa2028a36c2fc39e004924a28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscore__t.html">score_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a167b5492ba7b37e2cc6f546d49cc6b52">bestScoreLastColumn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true if first columns is gapped  <a href="#a167b5492ba7b37e2cc6f546d49cc6b52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscore__t.html">score_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#ab82028c8bef958a003289bf76ed37064">bestScoreLastRow</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#afedceae225a48ccd2428feed673a25be">seq0_offset</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">defines how many nucleotides were trimmed from the sequence 0  <a href="#afedceae225a48ccd2428feed673a25be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a73740bfaf8bef7ae6c663d14a43c172d">seq1_offset</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">defines how many nucleotides were trimmed from the sequence 1  <a href="#a73740bfaf8bef7ae6c663d14a43c172d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignerManager.html#a868a3ab5c9158c234d31a236ce7c9d4b">superPartition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPartition.html">Partition</a> that holds all sub-partitions.  <a href="#a868a3ab5c9158c234d31a236ce7c9d4b"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4b3c4eec965e0366b27f0b1de4eaf18e"></a><!-- doxytag: member="AlignerManager::AlignerManager" ref="a4b3c4eec965e0366b27f0b1de4eaf18e" args="(IAligner *aligner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignerManager.html#a4b3c4eec965e0366b27f0b1de4eaf18e">AlignerManager::AlignerManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIAligner.html">IAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00031">31</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74e366fb5475e68974172b199e433249"></a><!-- doxytag: member="AlignerManager::~AlignerManager" ref="a74e366fb5475e68974172b199e433249" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignerManager.html#a74e366fb5475e68974172b199e433249">AlignerManager::~AlignerManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00074">74</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5e8d4fba1a6db77782e6cd3b7e392f39"></a><!-- doxytag: member="AlignerManager::alignPartition" ref="a5e8d4fba1a6db77782e6cd3b7e392f39" args="(Partition partition, int startType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a5e8d4fba1a6db77782e6cd3b7e392f39">AlignerManager::alignPartition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a>&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00091">91</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73d065da73a1865f0a6b1e2ff9768774"></a><!-- doxytag: member="AlignerManager::dispatchColumn" ref="a73d065da73a1865f0a6b1e2ff9768774" args="(int j, const cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a73d065da73a1865f0a6b1e2ff9768774">AlignerManager::dispatchColumn</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies to the MASA framework that some cells of a column has been processed. </p>
<p>This function must be called serially for each column. For example, the invocation of dispatchColumn(50000, vector, 100) will dispatch the first 100 cells of the column 50000 to MASA, and the cells are read from the vector[0..99] elements. After this, a call to dispatchColumn(50000, vector, 50) will dispatch the next 50 cells of the same column 5000, and the cells are read from the vector[0..49] elements.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>the column to be dispatched. </td></tr>
    <tr><td class="paramname">buffer</td><td>the vector containing the data (starting from cell 0). </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read from the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIManager.html#add1d39604472d166b32e5828b8beb3ca">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00334">334</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0ac0d35378c6a7fb3ebe60d72e26307"></a><!-- doxytag: member="AlignerManager::dispatchRow" ref="aa0ac0d35378c6a7fb3ebe60d72e26307" args="(int i, const cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#aa0ac0d35378c6a7fb3ebe60d72e26307">AlignerManager::dispatchRow</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies to the MASA framework that some cells of a row has been processed. </p>
<p>This function must be called serially for each row, analogous to the AbstractAligner::dispatchLastColumn method.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row to be dispatched. </td></tr>
    <tr><td class="paramname">buffer</td><td>the vector containing the data (starting from cell 0). </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read from the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIManager.html#a72c77606165f415a230d4606cdfa407d">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00374">374</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa31b355182487edfc7097cc65a03a88f"></a><!-- doxytag: member="AlignerManager::dispatchScore" ref="aa31b355182487edfc7097cc65a03a88f" args="(score_t score, int bx=&#45;1, int by=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#aa31b355182487edfc7097cc65a03a88f">AlignerManager::dispatchScore</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscore__t.html">score_t</a>&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bx</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies to the MASA framework that a new score has been computed. </p>
<p>This method may be called as many times it is necessary, and the best score will be calculated among all calls of this method.</p>
<p>If the Aligner supports the <a class="el" href="structaligner__capabilities__t.html#a6894b92fb6480c2cfe920f38f312a95e" title="Dispatches scores in a regular block pattern.">aligner_capabilities_t::dispatch_block_scores</a> capability, them it must dispatch the score with the bx, by parameters set to the block indices and this method must be called only once for each block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">score</td><td>the score to be dispatched </td></tr>
    <tr><td class="paramname">bx</td><td>the block position in the horizontal direction, starting from 0 up to AbstractAligner::getGridWidth() minus 1. </td></tr>
    <tr><td class="paramname">by</td><td>the block position in the vertical direction, starting from 0 up to AbstractAligner::getGridHeight() minus 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIManager.html#a400b8952cf59c23d9b0cdc92cfd51b3e">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00411">411</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe43b2212ca01c212c42c1302c3b3532"></a><!-- doxytag: member="AlignerManager::findBestCell" ref="abe43b2212ca01c212c42c1302c3b3532" args="(const cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#abe43b2212ca01c212c42c1302c3b3532">AlignerManager::findBestCell</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00611">611</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f6bfaeb630309dfac87eb3743c15897"></a><!-- doxytag: member="AlignerManager::findFullGap" ref="a7f6bfaeb630309dfac87eb3743c15897" args="(int len, bool openGap, SeekableCellsReader *cellsReader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatch__result__t.html">match_result_t</a> <a class="el" href="classAlignerManager.html#a7f6bfaeb630309dfac87eb3743c15897">AlignerManager::findFullGap</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>openGap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td>
          <td class="paramname"><em>cellsReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00658">658</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cb589a2bd2dd59348c4341740fbd7af"></a><!-- doxytag: member="AlignerManager::findGoalCell" ref="a2cb589a2bd2dd59348c4341740fbd7af" args="(const cell_t *buffer, cell_t *base, int len, CellsReader *cellsReader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatch__result__t.html">match_result_t</a> <a class="el" href="classAlignerManager.html#a2cb589a2bd2dd59348c4341740fbd7af">AlignerManager::findGoalCell</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCellsReader.html">CellsReader</a> *&#160;</td>
          <td class="paramname"><em>cellsReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00625">625</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab292711adc4a805fb744b7bd2d299e88"></a><!-- doxytag: member="AlignerManager::getBestScoreLastColumn" ref="ab292711adc4a805fb744b7bd2d299e88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscore__t.html">score_t</a> <a class="el" href="classAlignerManager.html#ab292711adc4a805fb744b7bd2d299e88">AlignerManager::getBestScoreLastColumn</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00720">720</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c342affed4d58b3bd1ccde547b14bda"></a><!-- doxytag: member="AlignerManager::getBestScoreLastRow" ref="a6c342affed4d58b3bd1ccde547b14bda" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscore__t.html">score_t</a> <a class="el" href="classAlignerManager.html#a6c342affed4d58b3bd1ccde547b14bda">AlignerManager::getBestScoreLastRow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00724">724</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a743a9b05e455d0482dfffc7be6415922"></a><!-- doxytag: member="AlignerManager::getFirstColumnInitType" ref="a743a9b05e455d0482dfffc7be6415922" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a743a9b05e455d0482dfffc7be6415922">AlignerManager::getFirstColumnInitType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the initialization type of the first column. </p>
<p>Possible values are </p>
<ul>
<li>
<p class="startli">INIT_WITH_CUSTOM_DATA: the first column must be initialized with custom data that can only be obtained by the <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6" title="Delegates to IManager::receiveFirstColumn()">AbstractAligner::receiveFirstColumn</a> method. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS: the first column must be initialized considering gaps. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,0} &amp;=&amp; 0 \\ H_{k,0} &amp;=&amp; -k.G_{ext}-G_{open} \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_13.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS_OPENED: the first column must be initialized considering gaps, but without gap opening penalty. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{k,0} &amp;=&amp; -k.G_{ext} \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_14.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_ZEROES: the first column must be initialized considering zero values. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{k,0} &amp;=&amp; 0 \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_15.png"/>
</p>
 <p>The initialization data of all types may be obtained by the <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6" title="Delegates to IManager::receiveFirstColumn()">AbstractAligner::receiveFirstColumn</a> method, but the subclass of <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> may implement the initialization functions using some architectural dependent code (for example, using vectorial hardware instructions).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the initialization type. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#ae89c12af219f421da96c1ac22af01ea5">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00542">542</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0383e253450267ff0eae9906235e12f8"></a><!-- doxytag: member="AlignerManager::getFirstRowInitType" ref="a0383e253450267ff0eae9906235e12f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a0383e253450267ff0eae9906235e12f8">AlignerManager::getFirstRowInitType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the initialization type of the first row. </p>
<p>Possible values are </p>
<ul>
<li>
<p class="startli">INIT_WITH_CUSTOM_DATA: the first row must be initialized with custom data that can only be obtained by the <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d" title="Delegates to IManager::receiveFirstRow()">AbstractAligner::receiveFirstRow</a> method. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS: the first column must be initialized considering gaps. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,0} &amp;=&amp; 0 \\ H_{0,k} &amp;=&amp; -k.G_{ext}-G_{open} \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_16.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS_OPENED: the first column must be initialized considering gaps, but without gap opening penalty. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,k} &amp;=&amp; -k.G_{ext} \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_17.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_ZEROES: the first row must be initialized considering zero values. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,k} &amp;=&amp; 0 \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_18.png"/>
</p>
 <p>The initialization data of all types may be obtained by the <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d" title="Delegates to IManager::receiveFirstRow()">AbstractAligner::receiveFirstRow</a> method, but the subclass of <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> may implement the initialization functions using some architectural dependent code (for example, using vectorial hardware instructions).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the initialization type. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a41254fba0cfeccbf4c1ba9c5daa7928e">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00561">561</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f092338447c9ecb597ed3c8c6a5be7e"></a><!-- doxytag: member="AlignerManager::getNextCrosspoint" ref="a8f092338447c9ecb597ed3c8c6a5be7e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcrosspoint__t.html">crosspoint_t</a> <a class="el" href="classAlignerManager.html#a8f092338447c9ecb597ed3c8c6a5be7e">AlignerManager::getNextCrosspoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the callback function that will be called whenever the dispatchRow method is called for the last row. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">processLastRowFunction</td><td>the callback function. Defines the callback function that will be called whenever the dispatchColumn method is called for the last column.</td></tr>
    <tr><td class="paramname">processLastColumnFunction</td><td>the callback function. Defines the callback function that will be called whenever the dispatchScore method is called.</td></tr>
    <tr><td class="paramname">processBlockFunction</td><td>the callback function. Defines the callback function that will be called whenever the dispatchScore method is called for the last cell (right-bottom most cell).</td></tr>
    <tr><td class="paramname">processLastCellFunction</td><td>the callback function. Return the next crosspoint found by the matching procedure or by the goal score. If it was not found, the returned crosspoint score is -INF. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00593">593</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c223d348306015e09dc9e4514316ca1"></a><!-- doxytag: member="AlignerManager::getRecurrenceType" ref="a9c223d348306015e09dc9e4514316ca1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a9c223d348306015e09dc9e4514316ca1">AlignerManager::getRecurrenceType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the recurrence type of the alignment. Possible values are SMITH_WATERMAN and NEEDLEMAN_WUNSCH. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a1e389d0cf094847cc91b98dd22a155de">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00508">508</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb3156c988845ca60ec8c8a72c85a6c9"></a><!-- doxytag: member="AlignerManager::getSpecialColumnInterval" ref="adb3156c988845ca60ec8c8a72c85a6c9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#adb3156c988845ca60ec8c8a72c85a6c9">AlignerManager::getSpecialColumnInterval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum distance between two special columns, or 0 if it must not save special columns. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a8c60a1269909d9388627063d5b48eaef">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00519">519</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb5b19ee122a1896ae51b27974bf1a47"></a><!-- doxytag: member="AlignerManager::getSpecialRowInterval" ref="afb5b19ee122a1896ae51b27974bf1a47" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#afb5b19ee122a1896ae51b27974bf1a47">AlignerManager::getSpecialRowInterval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum distance between two special rows, or 0 if it must not save special rows. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a982e656c11981976af06d53eddb205f8">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00515">515</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="addab2775f67799bf337c277f36a67a63"></a><!-- doxytag: member="AlignerManager::getSuperPartition" ref="addab2775f67799bf337c277f36a67a63" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition.html">Partition</a> <a class="el" href="classAlignerManager.html#addab2775f67799bf337c277f36a67a63">AlignerManager::getSuperPartition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the super partition that includes all sub partitions being aligned. </p>
<p>This method must be used only by block pruning algorithms in order to obtain the corner coordinates of the matrix.</p>
<p>A super partition is a set of many smaller partitions and this occurs in two situations. The first is when we are running stage1 in a multiprocess environment, where we have one sub partition for each process. The second situation happens when the aligner cannot handle the full size of the matrix, so the partition is split in parts smaller than the max sequence size capability of the aligner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the super partition. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00268">268</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a783a9731031b2536f3494bbbb4810f2e"></a><!-- doxytag: member="AlignerManager::isFoundCrosspoint" ref="a783a9731031b2536f3494bbbb4810f2e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a783a9731031b2536f3494bbbb4810f2e">AlignerManager::isFoundCrosspoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the next crosspoint was found. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00607">607</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee7de63878b30b0a9f2a2f785ad34dc9"></a><!-- doxytag: member="AlignerManager::mustContinue" ref="aee7de63878b30b0a9f2a2f785ad34dc9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#aee7de63878b30b0a9f2a2f785ad34dc9">AlignerManager::mustContinue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the execution must continue. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#ac62975691de49a590609d704f142f296">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00527">527</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03ab541b69e2e75f66ed6028fa76e03f"></a><!-- doxytag: member="AlignerManager::mustDispatchLastCell" ref="a03ab541b69e2e75f66ed6028fa76e03f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a03ab541b69e2e75f66ed6028fa76e03f">AlignerManager::mustDispatchLastCell</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last cell must be dispatched. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a8f610b4b910c5e34fdf96a5001ebcdec">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00455">455</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac869efe60c1e770d7e4ff3c4b2cb21ea"></a><!-- doxytag: member="AlignerManager::mustDispatchLastColumn" ref="ac869efe60c1e770d7e4ff3c4b2cb21ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#ac869efe60c1e770d7e4ff3c4b2cb21ea">AlignerManager::mustDispatchLastColumn</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last column must be dispatched. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#ab7dd86bcf073d6cb5e8560e67dd3b254">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00475">475</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919abaad137497db239d61ac2befd89d"></a><!-- doxytag: member="AlignerManager::mustDispatchLastRow" ref="a919abaad137497db239d61ac2befd89d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a919abaad137497db239d61ac2befd89d">AlignerManager::mustDispatchLastRow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last row must be dispatched. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a322c0655e762bb1bdf608cb53c993d89">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00463">463</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a907ed1a569587588f20052b4120afb66"></a><!-- doxytag: member="AlignerManager::mustDispatchScores" ref="a907ed1a569587588f20052b4120afb66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a907ed1a569587588f20052b4120afb66">AlignerManager::mustDispatchScores</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if intermediate scores must be dispatched. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#af803f6b9d43564cc66e8c23b886bb41c">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00501">501</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aee93cbff23e2ad92e53349563160e7"></a><!-- doxytag: member="AlignerManager::mustDispatchSpecialColumns" ref="a5aee93cbff23e2ad92e53349563160e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a5aee93cbff23e2ad92e53349563160e7">AlignerManager::mustDispatchSpecialColumns</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if special columns must be dispatched. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a0f121b6ad20a67c2dbfdd6ab0267f11b">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00494">494</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ef30369e3062bd038db5d1e523659cd"></a><!-- doxytag: member="AlignerManager::mustDispatchSpecialRows" ref="a4ef30369e3062bd038db5d1e523659cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a4ef30369e3062bd038db5d1e523659cd">AlignerManager::mustDispatchSpecialRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if special rows must be dispatched. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#a63ff7e11c9cb09452340b97dce07eff5">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00487">487</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34672d16562514529dbf75200f625fd2"></a><!-- doxytag: member="AlignerManager::mustPruneBlocks" ref="a34672d16562514529dbf75200f625fd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a34672d16562514529dbf75200f625fd2">AlignerManager::mustPruneBlocks</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if block pruning optimization may be used. </dd></dl>

<p>Implements <a class="el" href="classIManager.html#ae9248a331ce802360d55d61a849a3f72">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00535">535</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9594ac58132da5d5818bb1010fe22b48"></a><!-- doxytag: member="AlignerManager::receiveFirstColumn" ref="a9594ac58132da5d5818bb1010fe22b48" args="(cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a9594ac58132da5d5818bb1010fe22b48">AlignerManager::receiveFirstColumn</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives the first column of the partition. </p>
<p>This function may block until all the requested data is ready. So prefer to read data in chunks instead of reading the full first row. The data will be stored from 0 to len-1 positions of the vector passed in the parameters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector where the first column data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIManager.html#ab3b54a8cb5971d1c1ad1937192de0c96">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00318">318</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a1995a17b6e9d85af9ebd2233d560c0"></a><!-- doxytag: member="AlignerManager::receiveFirstRow" ref="a0a1995a17b6e9d85af9ebd2233d560c0" args="(cell_t *buffer, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a0a1995a17b6e9d85af9ebd2233d560c0">AlignerManager::receiveFirstRow</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives the first row of the partition. </p>
<p>This function may block until all the requested data is ready. So prefer to read data in chunks instead of reading the full first row. The data will be stored from 0 to len-1 positions of the vector passed in the parameters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector where the first row data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classIManager.html#a28dced18e7501938d924591c2ee47a81">IManager</a>.</p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00326">326</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3d7a8623943bed310e5ea627d8788f"></a><!-- doxytag: member="AlignerManager::setBestScoreList" ref="a8d3d7a8623943bed310e5ea627d8788f" args="(BestScoreList *bestScoreList, const int bestScoreLocation=AT_NOWHERE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a8d3d7a8623943bed310e5ea627d8788f">AlignerManager::setBestScoreList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBestScoreList.html">BestScoreList</a> *&#160;</td>
          <td class="paramname"><em>bestScoreList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bestScoreLocation</em> = <code><a class="el" href="Job_8hpp.html#aaa2ec5091c90242236244232f10e3aa8">AT_NOWHERE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the list to store the best scores. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bestScoreList</td><td>the list to store the best scores. </td></tr>
    <tr><td class="paramname">bestScoreLocation</td><td>where to check for best score. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00565">565</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a251c7f794ebb23101e3c5dd218fed50d"></a><!-- doxytag: member="AlignerManager::setBlockPruning" ref="a251c7f794ebb23101e3c5dd218fed50d" args="(bool blockPruning)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a251c7f794ebb23101e3c5dd218fed50d">AlignerManager::setBlockPruning</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blockPruning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines if the aligner may do the block pruning optimization. </p>
<p>Since there are situations that the block pruning is not permitted, so the aligner must respect when blockPruning is false.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">blockPruning</td><td>true if the aligner may prune blocks. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00195">195</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42a650ee90529c4379c517df3e801541"></a><!-- doxytag: member="AlignerManager::setBlocksFile" ref="a42a650ee90529c4379c517df3e801541" args="(BlocksFile *blocksFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a42a650ee90529c4379c517df3e801541">AlignerManager::setBlocksFile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlocksFile.html">BlocksFile</a> *&#160;</td>
          <td class="paramname"><em>blocksFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the file to store the best score of each block. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">blocksFile</td><td>the file to store the scores. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00575">575</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f1eebb42a28a06980514602bab81dc6"></a><!-- doxytag: member="AlignerManager::setFirstColumnSource" ref="a9f1eebb42a28a06980514602bab81dc6" args="(SeekableCellsReader *firstColumnReader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a9f1eebb42a28a06980514602bab81dc6">AlignerManager::setFirstColumnSource</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td>
          <td class="paramname"><em>firstColumnReader</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines that the first column must be initialized with a customized column. </p>
<p>The column is loaded from a Blocking <a class="el" href="classBuffer.html">Buffer</a>, so consider that the buffer will block the process if the requested data is not fully ready. So, the buffer must be read in chunks, in order to not block the entire execution.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">firstColumnBuffer</td><td>the blocking buffer that will contain the first column data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00216">216</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f5b3c12f542a46aaa501fdfcd59d47b"></a><!-- doxytag: member="AlignerManager::setFirstRowSource" ref="a1f5b3c12f542a46aaa501fdfcd59d47b" args="(SeekableCellsReader *firstColumnReader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a1f5b3c12f542a46aaa501fdfcd59d47b">AlignerManager::setFirstRowSource</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td>
          <td class="paramname"><em>firstColumnReader</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines that the first row must be initialized with a pre-defined row. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">firstRowGapped</td><td>If true, than the cells must be initialized considering gaps, otherwise the cells must be initialized with zeros. See <a class="el" href="classAbstractAligner.html#a2ab4132fcf3c30fd649a44eae598abb9" title="Delegates to IManager::getFirstRowInitType()">AbstractAligner::getFirstRowInitType</a> for the initialization functions. Defines that the first row must be initialized with a customized row. The column is loaded from a FILE.</td></tr>
    <tr><td class="paramname">firstRow</td><td>the file that contains the first column data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00247">247</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af22b2bade8c6bd56fe2a6ef9e3333e85"></a><!-- doxytag: member="AlignerManager::setGoalScore" ref="af22b2bade8c6bd56fe2a6ef9e3333e85" args="(int goalScore, const int goalScoreLocation=AT_NOWHERE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#af22b2bade8c6bd56fe2a6ef9e3333e85">AlignerManager::setGoalScore</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>goalScore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>goalScoreLocation</em> = <code><a class="el" href="Job_8hpp.html#aaa2ec5091c90242236244232f10e3aa8">AT_NOWHERE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whenever the aligner finds the goal score, the processing must stop. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00579">579</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a78615614a772bc27e46f1b30fea48a"></a><!-- doxytag: member="AlignerManager::setLastColumnDestination" ref="a8a78615614a772bc27e46f1b30fea48a" args="(CellsWriter *lastColumnWriter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a8a78615614a772bc27e46f1b30fea48a">AlignerManager::setLastColumnDestination</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCellsWriter.html">CellsWriter</a> *&#160;</td>
          <td class="paramname"><em>lastColumnWriter</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the destination of the last column. </p>
<p>The column is stored in a Blocking <a class="el" href="classBuffer.html">Buffer</a>, so consider that the buffer will block the process if the buffer is full.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lastColumnBuffer</td><td>the buffer that will receive the data of the last column. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00263">263</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab72ef729993a9effab3e0a99a86f9340"></a><!-- doxytag: member="AlignerManager::setLastColumnReader" ref="ab72ef729993a9effab3e0a99a86f9340" args="(SeekableCellsReader *lastColumnReader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#ab72ef729993a9effab3e0a99a86f9340">AlignerManager::setLastColumnReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td>
          <td class="paramname"><em>lastColumnReader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the previous special rows partition containing the rows to be matched against the last column/rows. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00288">288</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef82f6b927b4919caee5cb00ca400e47"></a><!-- doxytag: member="AlignerManager::setLastRowDestination" ref="aef82f6b927b4919caee5cb00ca400e47" args="(CellsWriter *lastRowWriter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#aef82f6b927b4919caee5cb00ca400e47">AlignerManager::setLastRowDestination</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCellsWriter.html">CellsWriter</a> *&#160;</td>
          <td class="paramname"><em>lastRowWriter</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00284">284</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a548c0ccac9a734cb7e30b8b059e877cf"></a><!-- doxytag: member="AlignerManager::setLastRowReader" ref="a548c0ccac9a734cb7e30b8b059e877cf" args="(SeekableCellsReader *lastRowReader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a548c0ccac9a734cb7e30b8b059e877cf">AlignerManager::setLastRowReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a> *&#160;</td>
          <td class="paramname"><em>lastRowReader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the previous special rows partition containing the rows to be matched against the last column/rows. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00292">292</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1785552dd5f9a07ed425ea6701714b11"></a><!-- doxytag: member="AlignerManager::setPenalties" ref="a1785552dd5f9a07ed425ea6701714b11" args="(const int match, const int mismatch, const int gapOpen, const int gapExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a1785552dd5f9a07ed425ea6701714b11">AlignerManager::setPenalties</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>gapOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>gapExtension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the variable penalty functions to be aligned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>Match score </td></tr>
    <tr><td class="paramname">mismatch</td><td>Mismatch score </td></tr>
    <tr><td class="paramname">gapOpen</td><td>Gap opening penalty </td></tr>
    <tr><td class="paramname">gapExtension</td><td>Gap extension penalty </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00549">549</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8943fd323d361c786bc48dec34f3486c"></a><!-- doxytag: member="AlignerManager::setRecurrenceType" ref="a8943fd323d361c786bc48dec34f3486c" args="(int recurrenceType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a8943fd323d361c786bc48dec34f3486c">AlignerManager::setRecurrenceType</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recurrenceType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines that the first column must be initialized with a pre-defined column. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">firstColumnGapped</td><td>If true, than the cells must be initialized considering gaps, otherwise the cells must be initialized with zeros. See <a class="el" href="classAbstractAligner.html#a4af4756383624780721d22c831e6bca9" title="Delegates to IManager::getFirstColumnInitType()">AbstractAligner::getFirstColumnInitType</a> for the initialization functions. Defines the recurrence type of the execution. </td></tr>
    <tr><td class="paramname">recurrenceType</td><td>can be SMITH_WATERMAN or NEEDLEMAN_WUNSCH. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00299">299</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa73b698b5abdb5e51fc6dd02dc96c0b7"></a><!-- doxytag: member="AlignerManager::setSequences" ref="aa73b698b5abdb5e51fc6dd02dc96c0b7" args="(Sequence *seq0, Sequence *seq1, int i0, int j0, int i1, int j1, FILE *stats=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#aa73b698b5abdb5e51fc6dd02dc96c0b7">AlignerManager::setSequences</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSequence.html">Sequence</a> *&#160;</td>
          <td class="paramname"><em>seq0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSequence.html">Sequence</a> *&#160;</td>
          <td class="paramname"><em>seq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stats</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the partition that must be processed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>start row </td></tr>
    <tr><td class="paramname">j0</td><td>start column </td></tr>
    <tr><td class="paramname">i1</td><td>end row (exclusive) </td></tr>
    <tr><td class="paramname">j1</td><td>end column (exclusive) </td></tr>
    <tr><td class="paramname">start_type</td><td>The start type of the partition. See AbstractAligner::startType. Defines the sequences and the range of the sequences that will be aligned. This method also defines the range of the sequences that will be used in the alignPartitions. Note that the [i0,i1) and [j0,j1) are not the partition itself, but all the aligned partitions will reside inside this range. If the parameters $i0$ and $j0$ are positive, then the sequence data passed to the aligner is shifted, starting in positions $i0$ and $j0$. This allows the reduction of memory consumption, trimming the prefix of the sequences that would never be used (i.e. the memory may be allocated solely for the given sequence ranges.).</td></tr>
    <tr><td class="paramname">seq0</td><td>vertical sequence object. </td></tr>
    <tr><td class="paramname">seq1</td><td>horizontal sequence object. </td></tr>
    <tr><td class="paramname">i0</td><td>lowest position in seq0 that may be aligned. </td></tr>
    <tr><td class="paramname">j0</td><td>lowest position in seq1 that may be aligned. </td></tr>
    <tr><td class="paramname">i1</td><td>highest position in seq0 that may be aligned. </td></tr>
    <tr><td class="paramname">j1</td><td>highest position in seq1 that may be aligned. </td></tr>
    <tr><td class="paramname">stats</td><td>the statistics log file </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00173">173</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeff103ccc690b0a9e9c4d488e4584ed4"></a><!-- doxytag: member="AlignerManager::setSpecialRowInterval" ref="aeff103ccc690b0a9e9c4d488e4584ed4" args="(const int specialRowInterval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#aeff103ccc690b0a9e9c4d488e4584ed4">AlignerManager::setSpecialRowInterval</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>specialRowInterval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the minimum distance (in rows) between two special rows. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">specialRowInterval</td><td>the minimum interval between special rows. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00313">313</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8acb8834b8bbed891b5761472d4ad32"></a><!-- doxytag: member="AlignerManager::setSpecialRowsPartition" ref="ad8acb8834b8bbed891b5761472d4ad32" args="(SpecialRowsPartition *specialRowsPartition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#ad8acb8834b8bbed891b5761472d4ad32">AlignerManager::setSpecialRowsPartition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSpecialRowsPartition.html">SpecialRowsPartition</a> *&#160;</td>
          <td class="paramname"><em>specialRowsPartition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the grid dimension of the grid, if capabilities_t::dispatch_block_scores is SUPPORTED. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>the width of the grid. </td></tr>
    <tr><td class="paramname">height</td><td>the height of the grid. Defines the partition where the special rows will be stored. </td></tr>
    <tr><td class="paramname">specialRowsPartition</td><td>the special row partition. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00306">306</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f961cf23649cdca51a7901e006a9af3"></a><!-- doxytag: member="AlignerManager::setSuperPartition" ref="a4f961cf23649cdca51a7901e006a9af3" args="(Partition superPartition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a4f961cf23649cdca51a7901e006a9af3">AlignerManager::setSuperPartition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a>&#160;</td>
          <td class="paramname"><em>superPartition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the super-partition being aligned to be returned by the <a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d" title="Returns the super partition that includes all sub partitions being aligned.">IManager::getSuperPartition()</a> method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">superPartition</td><td>the super partition to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d" title="Returns the super partition that includes all sub partitions being aligned.">IManager::getSuperPartition()</a> </dd></dl>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00276">276</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3525b0d0a5b5c5ab48ad60773a2f036"></a><!-- doxytag: member="AlignerManager::stopAligner" ref="ab3525b0d0a5b5c5ab48ad60773a2f036" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#ab3525b0d0a5b5c5ab48ad60773a2f036">AlignerManager::stopAligner</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops the execution of the aligner. </p>
<p>This makes the <a class="el" href="classAlignerManager.html#aee7de63878b30b0a9f2a2f785ad34dc9">mustContinue()</a> method to return false. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00523">523</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a486fa727f81bc7733cc05ba136329411"></a><!-- doxytag: member="AlignerManager::unsetGoalScore" ref="a486fa727f81bc7733cc05ba136329411" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a486fa727f81bc7733cc05ba136329411">AlignerManager::unsetGoalScore</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do not find best score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00588">588</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f687a923143258bf8959a411c815205"></a><!-- doxytag: member="AlignerManager::unsetSequences" ref="a1f687a923143258bf8959a411c815205" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a1f687a923143258bf8959a411c815205">AlignerManager::unsetSequences</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear all sequence strucutures. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00186">186</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bef05cdfe88c521e38ba41dfd1a2ccd"></a><!-- doxytag: member="AlignerManager::unsetSuperPartition" ref="a8bef05cdfe88c521e38ba41dfd1a2ccd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignerManager.html#a8bef05cdfe88c521e38ba41dfd1a2ccd">AlignerManager::unsetSuperPartition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the super-partition. </p>
<p>A reseted super-partition means that it will always be equal to the current aligned partition. </p>

<p>Definition at line <a class="el" href="AlignerManager_8cpp_source.html#l00280">280</a> of file <a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3f0b8ba5b79fb03b71371ec417f57df0"></a><!-- doxytag: member="AlignerManager::active" ref="a3f0b8ba5b79fb03b71371ec417f57df0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a3f0b8ba5b79fb03b71371ec417f57df0">AlignerManager::active</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00272">272</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accb5b17e676541385aff9852cb0da086"></a><!-- doxytag: member="AlignerManager::aligner" ref="accb5b17e676541385aff9852cb0da086" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIAligner.html">IAligner</a>* <a class="el" href="classAlignerManager.html#accb5b17e676541385aff9852cb0da086">AlignerManager::aligner</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The aligner object that executes the SW computation. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00275">275</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4de31d2ee14231adfe162d31d2a0bf66"></a><!-- doxytag: member="AlignerManager::baseColumn" ref="a4de31d2ee14231adfe162d31d2a0bf66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcell__t.html">cell_t</a>* <a class="el" href="classAlignerManager.html#a4de31d2ee14231adfe162d31d2a0bf66">AlignerManager::baseColumn</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector that store the temporary cells for the matching procedures. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00293">293</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbfd473273bb90678aa6e8e59071cb8e"></a><!-- doxytag: member="AlignerManager::baseRow" ref="abbfd473273bb90678aa6e8e59071cb8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcell__t.html">cell_t</a>* <a class="el" href="classAlignerManager.html#abbfd473273bb90678aa6e8e59071cb8e">AlignerManager::baseRow</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector that store the temporary cells for the matching procedures. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00298">298</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a167b5492ba7b37e2cc6f546d49cc6b52"></a><!-- doxytag: member="AlignerManager::bestScoreLastColumn" ref="a167b5492ba7b37e2cc6f546d49cc6b52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscore__t.html">score_t</a> <a class="el" href="classAlignerManager.html#a167b5492ba7b37e2cc6f546d49cc6b52">AlignerManager::bestScoreLastColumn</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true if first columns is gapped </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00405">405</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab82028c8bef958a003289bf76ed37064"></a><!-- doxytag: member="AlignerManager::bestScoreLastRow" ref="ab82028c8bef958a003289bf76ed37064" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscore__t.html">score_t</a> <a class="el" href="classAlignerManager.html#ab82028c8bef958a003289bf76ed37064">AlignerManager::bestScoreLastRow</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00406">406</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96256feafe27cbe8edf7bfeffbaa2402"></a><!-- doxytag: member="AlignerManager::bestScoreList" ref="a96256feafe27cbe8edf7bfeffbaa2402" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBestScoreList.html">BestScoreList</a>* <a class="el" href="classAlignerManager.html#a96256feafe27cbe8edf7bfeffbaa2402">AlignerManager::bestScoreList</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List with the best scores. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00339">339</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1081926183696243fb9ffa34b005b46e"></a><!-- doxytag: member="AlignerManager::bestScoreLocation" ref="a1081926183696243fb9ffa34b005b46e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a1081926183696243fb9ffa34b005b46e">AlignerManager::bestScoreLocation</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Where to check best score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00357">357</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3c61a7000db68aebfe7f29f4d415431"></a><!-- doxytag: member="AlignerManager::blockPruning" ref="ad3c61a7000db68aebfe7f29f4d415431" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#ad3c61a7000db68aebfe7f29f4d415431">AlignerManager::blockPruning</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for the last rows. </p>
<p>Callback for the last cells Callback for the scores Callback for the last score true if block must be pruned </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00378">378</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32cf9aa11a2c8840798df9f724f3e9e9"></a><!-- doxytag: member="AlignerManager::blocksFile" ref="a32cf9aa11a2c8840798df9f724f3e9e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlocksFile.html">BlocksFile</a>* <a class="el" href="classAlignerManager.html#a32cf9aa11a2c8840798df9f724f3e9e9">AlignerManager::blocksFile</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00354">354</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12acc9ba82b991e9b365d2b981d177a8"></a><!-- doxytag: member="AlignerManager::firstColumnInitType" ref="a12acc9ba82b991e9b365d2b981d177a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a12acc9ba82b991e9b365d2b981d177a8">AlignerManager::firstColumnInitType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First row tracking position for the receive procedure. </p>
<p>First column tracking position for the receive procedure </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00395">395</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac891b6675396606c5daea67541a87fc9"></a><!-- doxytag: member="AlignerManager::firstColumnReader" ref="ac891b6675396606c5daea67541a87fc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a>* <a class="el" href="classAlignerManager.html#ac891b6675396606c5daea67541a87fc9">AlignerManager::firstColumnReader</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First column blocking buffer. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00324">324</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a0c904d871fe2f9be118149d7dde3c6"></a><!-- doxytag: member="AlignerManager::firstRowFile" ref="a9a0c904d871fe2f9be118149d7dde3c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="classAlignerManager.html#a9a0c904d871fe2f9be118149d7dde3c6">AlignerManager::firstRowFile</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>File where the first row is stored. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00387">387</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c93b95fa2028a36c2fc39e004924a28"></a><!-- doxytag: member="AlignerManager::firstRowInitType" ref="a9c93b95fa2028a36c2fc39e004924a28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a9c93b95fa2028a36c2fc39e004924a28">AlignerManager::firstRowInitType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true if first row is gapped </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00400">400</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af138031e21d703e1cb99b3eb63876cb8"></a><!-- doxytag: member="AlignerManager::firstRowReader" ref="af138031e21d703e1cb99b3eb63876cb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a>* <a class="el" href="classAlignerManager.html#af138031e21d703e1cb99b3eb63876cb8">AlignerManager::firstRowReader</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First row blocking buffer. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00327">327</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a901ff6fc2788bb903264c043f7645088"></a><!-- doxytag: member="AlignerManager::foundCrosspoint" ref="a901ff6fc2788bb903264c043f7645088" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAlignerManager.html#a901ff6fc2788bb903264c043f7645088">AlignerManager::foundCrosspoint</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates if the next crosspoint has already been found. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00348">348</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a738bb13a928ed3c35a2753e11cf3992f"></a><!-- doxytag: member="AlignerManager::gapExtension" ref="a738bb13a928ed3c35a2753e11cf3992f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a738bb13a928ed3c35a2753e11cf3992f">AlignerManager::gapExtension</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gap extension penalty. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00321">321</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35a9f948020f4996bc0c07aba10a6753"></a><!-- doxytag: member="AlignerManager::gapOpen" ref="a35a9f948020f4996bc0c07aba10a6753" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a35a9f948020f4996bc0c07aba10a6753">AlignerManager::gapOpen</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gap opening penalty. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00318">318</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1f57b3b06b31a72a043ab67cc376bc0"></a><!-- doxytag: member="AlignerManager::goalScore" ref="aa1f57b3b06b31a72a043ab67cc376bc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#aa1f57b3b06b31a72a043ab67cc376bc0">AlignerManager::goalScore</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The aligner must stop whenever it finds the goal score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00342">342</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab03e4bd168f79541f7feb22a751d2657"></a><!-- doxytag: member="AlignerManager::goalScoreLocation" ref="ab03e4bd168f79541f7feb22a751d2657" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#ab03e4bd168f79541f7feb22a751d2657">AlignerManager::goalScoreLocation</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Where to check the goal score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00345">345</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8651cb254f79c9521366e05ae98c7b8e"></a><!-- doxytag: member="AlignerManager::lastColumnPos" ref="a8651cb254f79c9521366e05ae98c7b8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a8651cb254f79c9521366e05ae98c7b8e">AlignerManager::lastColumnPos</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Column tracking position for the dispatching procedure. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00360">360</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec69ec1a443e891d3348319e6c3975c6"></a><!-- doxytag: member="AlignerManager::lastColumnReader" ref="aec69ec1a443e891d3348319e6c3975c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a>* <a class="el" href="classAlignerManager.html#aec69ec1a443e891d3348319e6c3975c6">AlignerManager::lastColumnReader</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The reader that provides the last column saved in memory/disk. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00283">283</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a679c45a0d31f4a27db61631dede99f73"></a><!-- doxytag: member="AlignerManager::lastColumnWriter" ref="a679c45a0d31f4a27db61631dede99f73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellsWriter.html">CellsWriter</a>* <a class="el" href="classAlignerManager.html#a679c45a0d31f4a27db61631dede99f73">AlignerManager::lastColumnWriter</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Last column blocking buffer. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00330">330</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab40581ae0aacc906b60898d3b70577d9"></a><!-- doxytag: member="AlignerManager::lastRowPos" ref="ab40581ae0aacc906b60898d3b70577d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#ab40581ae0aacc906b60898d3b70577d9">AlignerManager::lastRowPos</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Row tracking position for the dispatching procedure. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00363">363</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebd2ce79f17b5f9dc9f88d79ed9234b3"></a><!-- doxytag: member="AlignerManager::lastRowReader" ref="aebd2ce79f17b5f9dc9f88d79ed9234b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSeekableCellsReader.html">SeekableCellsReader</a>* <a class="el" href="classAlignerManager.html#aebd2ce79f17b5f9dc9f88d79ed9234b3">AlignerManager::lastRowReader</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The reader that provides the last rows saved in memory/disk. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00288">288</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a627fe61522e1f41d68ee5090f9c65b38"></a><!-- doxytag: member="AlignerManager::lastRowWriter" ref="a627fe61522e1f41d68ee5090f9c65b38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellsWriter.html">CellsWriter</a>* <a class="el" href="classAlignerManager.html#a627fe61522e1f41d68ee5090f9c65b38">AlignerManager::lastRowWriter</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Last row blocking buffer. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00333">333</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af854877ee7c0e69746533ad5ba910d15"></a><!-- doxytag: member="AlignerManager::match" ref="af854877ee7c0e69746533ad5ba910d15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#af854877ee7c0e69746533ad5ba910d15">AlignerManager::match</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Match Score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00312">312</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a741dd13bf1725aa0248d2774fb03b95f"></a><!-- doxytag: member="AlignerManager::mismatch" ref="a741dd13bf1725aa0248d2774fb03b95f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a741dd13bf1725aa0248d2774fb03b95f">AlignerManager::mismatch</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mismatch Score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00315">315</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60d4aaa07df4178f4dc68045c37964ba"></a><!-- doxytag: member="AlignerManager::nextCrosspoint" ref="a60d4aaa07df4178f4dc68045c37964ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcrosspoint__t.html">crosspoint_t</a> <a class="el" href="classAlignerManager.html#a60d4aaa07df4178f4dc68045c37964ba">AlignerManager::nextCrosspoint</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The crosspoint found by the matching procedure or the goal score. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00351">351</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0dfd7b941d6cb6eab1518a5890fd2aad"></a><!-- doxytag: member="AlignerManager::partition" ref="a0dfd7b941d6cb6eab1518a5890fd2aad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition.html">Partition</a> <a class="el" href="classAlignerManager.html#a0dfd7b941d6cb6eab1518a5890fd2aad">AlignerManager::partition</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The partition that is being aligned. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00278">278</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6836950e521154fd4ec97fddadf2ec8a"></a><!-- doxytag: member="AlignerManager::recurrenceType" ref="a6836950e521154fd4ec97fddadf2ec8a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a6836950e521154fd4ec97fddadf2ec8a">AlignerManager::recurrenceType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>required recurrence type (SMITH_WATERMAN or NEEDLEMAN_WUNSCH) </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00381">381</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16cee18fd0a904ef5bd2ae426c5e9499"></a><!-- doxytag: member="AlignerManager::score_params" ref="a16cee18fd0a904ef5bd2ae426c5e9499" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structscore__params__t.html">score_params_t</a>* <a class="el" href="classAlignerManager.html#a16cee18fd0a904ef5bd2ae426c5e9499">AlignerManager::score_params</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Math/mismatch/gaps parameters. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00301">301</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afedceae225a48ccd2428feed673a25be"></a><!-- doxytag: member="AlignerManager::seq0_offset" ref="afedceae225a48ccd2428feed673a25be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#afedceae225a48ccd2428feed673a25be">AlignerManager::seq0_offset</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>defines how many nucleotides were trimmed from the sequence 0 </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00417">417</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73740bfaf8bef7ae6c663d14a43c172d"></a><!-- doxytag: member="AlignerManager::seq1_offset" ref="a73740bfaf8bef7ae6c663d14a43c172d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a73740bfaf8bef7ae6c663d14a43c172d">AlignerManager::seq1_offset</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>defines how many nucleotides were trimmed from the sequence 1 </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00419">419</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ed63fbbf32bc7f0b51a18fa820f1f47"></a><!-- doxytag: member="AlignerManager::specialRowInterval" ref="a6ed63fbbf32bc7f0b51a18fa820f1f47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#a6ed63fbbf32bc7f0b51a18fa820f1f47">AlignerManager::specialRowInterval</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>minimum distance between two special rows </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00384">384</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61fe1518cbeb790cc89625a5fc9b46a1"></a><!-- doxytag: member="AlignerManager::specialRowsPartition" ref="a61fe1518cbeb790cc89625a5fc9b46a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpecialRowsPartition.html">SpecialRowsPartition</a>* <a class="el" href="classAlignerManager.html#a61fe1518cbeb790cc89625a5fc9b46a1">AlignerManager::specialRowsPartition</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classPartition.html">Partition</a> where the Special Rows are stored. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00336">336</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5dbca34b32c275a859a21838e02c6cc"></a><!-- doxytag: member="AlignerManager::startType" ref="ac5dbca34b32c275a859a21838e02c6cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAlignerManager.html#ac5dbca34b32c275a859a21838e02c6cc">AlignerManager::startType</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The start type of the partition. </p>
<p>Possible values are: TYPE_MATCH, TYPE_GAP_1 or TYPE_GAP_2. When set to the TYPE_GAP_1 or TYPE_GAP_2, the initialization of the first row/column must be done without the gap opening penalty. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00309">309</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a868a3ab5c9158c234d31a236ce7c9d4b"></a><!-- doxytag: member="AlignerManager::superPartition" ref="a868a3ab5c9158c234d31a236ce7c9d4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition.html">Partition</a> <a class="el" href="classAlignerManager.html#a868a3ab5c9158c234d31a236ce7c9d4b">AlignerManager::superPartition</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classPartition.html">Partition</a> that holds all sub-partitions. </p>
<p>If there are no sub-partition, this is the single partition being aligned. </p>

<p>Definition at line <a class="el" href="AlignerManager_8hpp_source.html#l00425">425</a> of file <a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="AlignerManager_8hpp_source.html">AlignerManager.hpp</a></li>
<li><a class="el" href="AlignerManager_8cpp_source.html">AlignerManager.cpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri May 8 2015 11:39:22 for MASA-Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
