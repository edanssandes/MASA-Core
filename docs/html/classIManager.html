<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MASA-Core: IManager Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MASA-Core
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">IManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="IManager" --><hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Interface that manages the MASA extension execution. </p>
<p>The MASA framework has an implementation of the <a class="el" href="classIManager.html" title="Interface that manages the MASA extension execution.">IManager</a> interface, that is responsible to receive commands from the Aligner. These commands are classified in the following types:</p>
<ul>
<li>
<b>getXXX</b> methods: Return information about the desired alignment. For example, the get methods returns the coordinates of the partition to be aligned; the sequences data; the start type of the alignment </li>
<li>
<b>receiveXXX</b> methods: Receives rows or columns from the MASA framework. </li>
<li>
<b>dispatchXXX</b> methods: Sends rows or columns to the MASA framework. </li>
<li>
<b>mustXXX</b> methods: Returns true if some requirement must be activated. </li>
</ul>
<p>In order to test these conditional requirements, each aligner is associated with an instance of the <a class="el" href="classIManager.html" title="Interface that manages the MASA extension execution.">IManager</a> interface (see setManager() function). Besides the conditional requirement tests, the Manager also provides all the parameters necessary to customize the alignment, for example the sequences, the partitions coordinates. The <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> hides the <a class="el" href="classIManager.html" title="Interface that manages the MASA extension execution.">IManager</a> invocation using some delegate methods with protected visibility.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>The <a class="el" href="structaligner__capabilities__t.html" title="Struct that informs to the MASA framework which capabilities the MASA extension implements.">aligner_capabilities_t</a> struct describes all the possible capabilities and the requirement necessary to implement it. </dd>
<dd>
The <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> has many methods that helps the implementation of the <a class="el" href="classIAligner.html" title="Interface between the MASA extension and the MASA framework.">IAligner</a> interface. </dd>
<dd>
The <a class="el" href="classIManager.html" title="Interface that manages the MASA extension execution.">IManager</a> interface manages the execution of the <a class="el" href="classIAligner.html" title="Interface between the MASA extension and the MASA framework.">IAligner</a>. </dd></dl>

<p>Definition at line <a class="el" href="IManager_8hpp_source.html#l00090">90</a> of file <a class="el" href="IManager_8hpp_source.html">IManager.hpp</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="IManager_8hpp_source.html">IManager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classIManager.png" usemap="#IManager_map" alt=""/>
  <map id="IManager_map" name="IManager_map">
<area href="classAlignerManager.html" alt="AlignerManager" shape="rect" coords="0,56,104,80"/>
</map>
 </div></div>

<p><a href="classIManager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a1e389d0cf094847cc91b98dd22a155de">getRecurrenceType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a982e656c11981976af06d53eddb205f8">getSpecialRowInterval</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a8c60a1269909d9388627063d5b48eaef">getSpecialColumnInterval</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#ae89c12af219f421da96c1ac22af01ea5">getFirstColumnInitType</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the initialization type of the first column.  <a href="#ae89c12af219f421da96c1ac22af01ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a41254fba0cfeccbf4c1ba9c5daa7928e">getFirstRowInitType</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the initialization type of the first row.  <a href="#a41254fba0cfeccbf4c1ba9c5daa7928e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d">getSuperPartition</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the super partition that includes all sub partitions being aligned.  <a href="#a4b9435813d47ad24675150059063f33d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a28dced18e7501938d924591c2ee47a81">receiveFirstRow</a> (<a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the first row of the partition.  <a href="#a28dced18e7501938d924591c2ee47a81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#ab3b54a8cb5971d1c1ad1937192de0c96">receiveFirstColumn</a> (<a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the first column of the partition.  <a href="#ab3b54a8cb5971d1c1ad1937192de0c96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#add1d39604472d166b32e5828b8beb3ca">dispatchColumn</a> (int j, const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies to the MASA framework that some cells of a column has been processed.  <a href="#add1d39604472d166b32e5828b8beb3ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a72c77606165f415a230d4606cdfa407d">dispatchRow</a> (int i, const <a class="el" href="structcell__t.html">cell_t</a> *buffer, int len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies to the MASA framework that some cells of a row has been processed.  <a href="#a72c77606165f415a230d4606cdfa407d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a400b8952cf59c23d9b0cdc92cfd51b3e">dispatchScore</a> (<a class="el" href="structscore__t.html">score_t</a> score, int bx=-1, int by=-1)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies to the MASA framework that a new score has been computed.  <a href="#a400b8952cf59c23d9b0cdc92cfd51b3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#ac62975691de49a590609d704f142f296">mustContinue</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a8f610b4b910c5e34fdf96a5001ebcdec">mustDispatchLastCell</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a322c0655e762bb1bdf608cb53c993d89">mustDispatchLastRow</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#ab7dd86bcf073d6cb5e8560e67dd3b254">mustDispatchLastColumn</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a63ff7e11c9cb09452340b97dce07eff5">mustDispatchSpecialRows</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a0f121b6ad20a67c2dbfdd6ab0267f11b">mustDispatchSpecialColumns</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#af803f6b9d43564cc66e8c23b886bb41c">mustDispatchScores</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#ae9248a331ce802360d55d61a849a3f72">mustPruneBlocks</a> ()=0</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#ad4767e1f844741941b177e2a7a8bd41f">~IManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIManager.html#a8dc1f72d1fd5339983e4481000ca896d">IManager</a> ()</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad4767e1f844741941b177e2a7a8bd41f"></a><!-- doxytag: member="IManager::~IManager" ref="ad4767e1f844741941b177e2a7a8bd41f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIManager.html#ad4767e1f844741941b177e2a7a8bd41f">IManager::~IManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IManager_8hpp_source.html#l00317">317</a> of file <a class="el" href="IManager_8hpp_source.html">IManager.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8dc1f72d1fd5339983e4481000ca896d"></a><!-- doxytag: member="IManager::IManager" ref="a8dc1f72d1fd5339983e4481000ca896d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIManager.html#a8dc1f72d1fd5339983e4481000ca896d">IManager::IManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IManager_8hpp_source.html#l00318">318</a> of file <a class="el" href="IManager_8hpp_source.html">IManager.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="add1d39604472d166b32e5828b8beb3ca"></a><!-- doxytag: member="IManager::dispatchColumn" ref="add1d39604472d166b32e5828b8beb3ca" args="(int j, const cell_t *buffer, int len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIManager.html#add1d39604472d166b32e5828b8beb3ca">IManager::dispatchColumn</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies to the MASA framework that some cells of a column has been processed. </p>
<p>This function must be called serially for each column. For example, the invocation of dispatchColumn(50000, vector, 100) will dispatch the first 100 cells of the column 50000 to MASA, and the cells are read from the vector[0..99] elements. After this, a call to dispatchColumn(50000, vector, 50) will dispatch the next 50 cells of the same column 5000, and the cells are read from the vector[0..49] elements.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>the column to be dispatched. </td></tr>
    <tr><td class="paramname">buffer</td><td>the vector containing the data (starting from cell 0). </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read from the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a73d065da73a1865f0a6b1e2ff9768774">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a72c77606165f415a230d4606cdfa407d"></a><!-- doxytag: member="IManager::dispatchRow" ref="a72c77606165f415a230d4606cdfa407d" args="(int i, const cell_t *buffer, int len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIManager.html#a72c77606165f415a230d4606cdfa407d">IManager::dispatchRow</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies to the MASA framework that some cells of a row has been processed. </p>
<p>This function must be called serially for each row, analogous to the AbstractAligner::dispatchLastColumn method.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row to be dispatched. </td></tr>
    <tr><td class="paramname">buffer</td><td>the vector containing the data (starting from cell 0). </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read from the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#aa0ac0d35378c6a7fb3ebe60d72e26307">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a400b8952cf59c23d9b0cdc92cfd51b3e"></a><!-- doxytag: member="IManager::dispatchScore" ref="a400b8952cf59c23d9b0cdc92cfd51b3e" args="(score_t score, int bx=&#45;1, int by=&#45;1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIManager.html#a400b8952cf59c23d9b0cdc92cfd51b3e">IManager::dispatchScore</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscore__t.html">score_t</a>&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bx</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies to the MASA framework that a new score has been computed. </p>
<p>This method may be called as many times it is necessary, and the best score will be calculated among all calls of this method.</p>
<p>If the Aligner supports the <a class="el" href="structaligner__capabilities__t.html#a6894b92fb6480c2cfe920f38f312a95e" title="Dispatches scores in a regular block pattern.">aligner_capabilities_t::dispatch_block_scores</a> capability, them it must dispatch the score with the bx, by parameters set to the block indices and this method must be called only once for each block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">score</td><td>the score to be dispatched </td></tr>
    <tr><td class="paramname">bx</td><td>the block position in the horizontal direction, starting from 0 up to AbstractAligner::getGridWidth() minus 1. </td></tr>
    <tr><td class="paramname">by</td><td>the block position in the vertical direction, starting from 0 up to AbstractAligner::getGridHeight() minus 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#aa31b355182487edfc7097cc65a03a88f">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="ae89c12af219f421da96c1ac22af01ea5"></a><!-- doxytag: member="IManager::getFirstColumnInitType" ref="ae89c12af219f421da96c1ac22af01ea5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classIManager.html#ae89c12af219f421da96c1ac22af01ea5">IManager::getFirstColumnInitType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the initialization type of the first column. </p>
<p>Possible values are </p>
<ul>
<li>
<p class="startli">INIT_WITH_CUSTOM_DATA: the first column must be initialized with custom data that can only be obtained by the <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6" title="Delegates to IManager::receiveFirstColumn()">AbstractAligner::receiveFirstColumn</a> method. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS: the first column must be initialized considering gaps. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,0} &amp;=&amp; 0 \\ H_{k,0} &amp;=&amp; -k.G_{ext}-G_{open} \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_13.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS_OPENED: the first column must be initialized considering gaps, but without gap opening penalty. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{k,0} &amp;=&amp; -k.G_{ext} \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_14.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_ZEROES: the first column must be initialized considering zero values. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{k,0} &amp;=&amp; 0 \\ F_{k,0} &amp;=&amp; -\infty \end{eqnarray*}" src="form_15.png"/>
</p>
 <p>The initialization data of all types may be obtained by the <a class="el" href="classAbstractAligner.html#a5826f966c44d93208b7b8da6763f3eb6" title="Delegates to IManager::receiveFirstColumn()">AbstractAligner::receiveFirstColumn</a> method, but the subclass of <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> may implement the initialization functions using some architectural dependent code (for example, using vectorial hardware instructions).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the initialization type. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a743a9b05e455d0482dfffc7be6415922">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a41254fba0cfeccbf4c1ba9c5daa7928e"></a><!-- doxytag: member="IManager::getFirstRowInitType" ref="a41254fba0cfeccbf4c1ba9c5daa7928e" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classIManager.html#a41254fba0cfeccbf4c1ba9c5daa7928e">IManager::getFirstRowInitType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the initialization type of the first row. </p>
<p>Possible values are </p>
<ul>
<li>
<p class="startli">INIT_WITH_CUSTOM_DATA: the first row must be initialized with custom data that can only be obtained by the <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d" title="Delegates to IManager::receiveFirstRow()">AbstractAligner::receiveFirstRow</a> method. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS: the first column must be initialized considering gaps. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,0} &amp;=&amp; 0 \\ H_{0,k} &amp;=&amp; -k.G_{ext}-G_{open} \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_16.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_GAPS_OPENED: the first column must be initialized considering gaps, but without gap opening penalty. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,k} &amp;=&amp; -k.G_{ext} \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_17.png"/>
</p>
 <p class="endli"></p>
</li>
<li>
<p class="startli">INIT_WITH_ZEROES: the first row must be initialized considering zero values. The initialization equation is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*}H_{0,k} &amp;=&amp; 0 \\ F_{0,k} &amp;=&amp; -\infty \end{eqnarray*}" src="form_18.png"/>
</p>
 <p>The initialization data of all types may be obtained by the <a class="el" href="classAbstractAligner.html#a3b0b4d7e643f8d58a8887593070d021d" title="Delegates to IManager::receiveFirstRow()">AbstractAligner::receiveFirstRow</a> method, but the subclass of <a class="el" href="classAbstractAligner.html" title="Abstract class that executes the Alignment procedure.">AbstractAligner</a> may implement the initialization functions using some architectural dependent code (for example, using vectorial hardware instructions).</p>
<p class="endli"></p>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the initialization type. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a0383e253450267ff0eae9906235e12f8">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a1e389d0cf094847cc91b98dd22a155de"></a><!-- doxytag: member="IManager::getRecurrenceType" ref="a1e389d0cf094847cc91b98dd22a155de" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classIManager.html#a1e389d0cf094847cc91b98dd22a155de">IManager::getRecurrenceType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the recurrence type of the alignment. Possible values are SMITH_WATERMAN and NEEDLEMAN_WUNSCH. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a9c223d348306015e09dc9e4514316ca1">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a8c60a1269909d9388627063d5b48eaef"></a><!-- doxytag: member="IManager::getSpecialColumnInterval" ref="a8c60a1269909d9388627063d5b48eaef" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classIManager.html#a8c60a1269909d9388627063d5b48eaef">IManager::getSpecialColumnInterval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum distance between two special columns, or 0 if it must not save special columns. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#adb3156c988845ca60ec8c8a72c85a6c9">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a982e656c11981976af06d53eddb205f8"></a><!-- doxytag: member="IManager::getSpecialRowInterval" ref="a982e656c11981976af06d53eddb205f8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classIManager.html#a982e656c11981976af06d53eddb205f8">IManager::getSpecialRowInterval</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum distance between two special rows, or 0 if it must not save special rows. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#afb5b19ee122a1896ae51b27974bf1a47">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a4b9435813d47ad24675150059063f33d"></a><!-- doxytag: member="IManager::getSuperPartition" ref="a4b9435813d47ad24675150059063f33d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartition.html">Partition</a> <a class="el" href="classIManager.html#a4b9435813d47ad24675150059063f33d">IManager::getSuperPartition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the super partition that includes all sub partitions being aligned. </p>
<p>This method must be used only by block pruning algorithms in order to obtain the corner coordinates of the matrix.</p>
<p>A super partition is a set of many smaller partitions and this occurs in two situations. The first is when we are running stage1 in a multiprocess environment, where we have one sub partition for each process. The second situation happens when the aligner cannot handle the full size of the matrix, so the partition is split in parts smaller than the max sequence size capability of the aligner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the super partition. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#addab2775f67799bf337c277f36a67a63">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="ac62975691de49a590609d704f142f296"></a><!-- doxytag: member="IManager::mustContinue" ref="ac62975691de49a590609d704f142f296" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#ac62975691de49a590609d704f142f296">IManager::mustContinue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the execution must continue. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#aee7de63878b30b0a9f2a2f785ad34dc9">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a8f610b4b910c5e34fdf96a5001ebcdec"></a><!-- doxytag: member="IManager::mustDispatchLastCell" ref="a8f610b4b910c5e34fdf96a5001ebcdec" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#a8f610b4b910c5e34fdf96a5001ebcdec">IManager::mustDispatchLastCell</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last cell must be dispatched. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a03ab541b69e2e75f66ed6028fa76e03f">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="ab7dd86bcf073d6cb5e8560e67dd3b254"></a><!-- doxytag: member="IManager::mustDispatchLastColumn" ref="ab7dd86bcf073d6cb5e8560e67dd3b254" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#ab7dd86bcf073d6cb5e8560e67dd3b254">IManager::mustDispatchLastColumn</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last column must be dispatched. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#ac869efe60c1e770d7e4ff3c4b2cb21ea">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a322c0655e762bb1bdf608cb53c993d89"></a><!-- doxytag: member="IManager::mustDispatchLastRow" ref="a322c0655e762bb1bdf608cb53c993d89" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#a322c0655e762bb1bdf608cb53c993d89">IManager::mustDispatchLastRow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the last row must be dispatched. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a919abaad137497db239d61ac2befd89d">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="af803f6b9d43564cc66e8c23b886bb41c"></a><!-- doxytag: member="IManager::mustDispatchScores" ref="af803f6b9d43564cc66e8c23b886bb41c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#af803f6b9d43564cc66e8c23b886bb41c">IManager::mustDispatchScores</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if intermediate scores must be dispatched. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a907ed1a569587588f20052b4120afb66">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a0f121b6ad20a67c2dbfdd6ab0267f11b"></a><!-- doxytag: member="IManager::mustDispatchSpecialColumns" ref="a0f121b6ad20a67c2dbfdd6ab0267f11b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#a0f121b6ad20a67c2dbfdd6ab0267f11b">IManager::mustDispatchSpecialColumns</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if special columns must be dispatched. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a5aee93cbff23e2ad92e53349563160e7">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a63ff7e11c9cb09452340b97dce07eff5"></a><!-- doxytag: member="IManager::mustDispatchSpecialRows" ref="a63ff7e11c9cb09452340b97dce07eff5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#a63ff7e11c9cb09452340b97dce07eff5">IManager::mustDispatchSpecialRows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if special rows must be dispatched. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a4ef30369e3062bd038db5d1e523659cd">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="ae9248a331ce802360d55d61a849a3f72"></a><!-- doxytag: member="IManager::mustPruneBlocks" ref="ae9248a331ce802360d55d61a849a3f72" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classIManager.html#ae9248a331ce802360d55d61a849a3f72">IManager::mustPruneBlocks</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if block pruning optimization may be used. </dd></dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a34672d16562514529dbf75200f625fd2">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="ab3b54a8cb5971d1c1ad1937192de0c96"></a><!-- doxytag: member="IManager::receiveFirstColumn" ref="ab3b54a8cb5971d1c1ad1937192de0c96" args="(cell_t *buffer, int len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIManager.html#ab3b54a8cb5971d1c1ad1937192de0c96">IManager::receiveFirstColumn</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives the first column of the partition. </p>
<p>This function may block until all the requested data is ready. So prefer to read data in chunks instead of reading the full first row. The data will be stored from 0 to len-1 positions of the vector passed in the parameters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector where the first column data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a9594ac58132da5d5818bb1010fe22b48">AlignerManager</a>.</p>

</div>
</div>
<a class="anchor" id="a28dced18e7501938d924591c2ee47a81"></a><!-- doxytag: member="IManager::receiveFirstRow" ref="a28dced18e7501938d924591c2ee47a81" args="(cell_t *buffer, int len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classIManager.html#a28dced18e7501938d924591c2ee47a81">IManager::receiveFirstRow</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcell__t.html">cell_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives the first row of the partition. </p>
<p>This function may block until all the requested data is ready. So prefer to read data in chunks instead of reading the full first row. The data will be stored from 0 to len-1 positions of the vector passed in the parameters.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the vector where the first row data will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>the number of cells that will be read. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classAlignerManager.html#a0a1995a17b6e9d85af9ebd2233d560c0">AlignerManager</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="IManager_8hpp_source.html">IManager.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri May 8 2015 11:39:26 for MASA-Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
